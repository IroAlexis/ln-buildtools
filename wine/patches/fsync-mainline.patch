From 2166d9007f6aca5a7dc18a64482cf04c29fbe922 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 15:17:29 -0500
Subject: [PATCH 01/55] server: Create server objects for futex-based
 synchronization objects.

---
 server/Makefile.in  |   1 +
 server/fsync.c      | 286 ++++++++++++++++++++++++++++++++++++++++++++
 server/fsync.h      |  22 ++++
 server/main.c       |   4 +
 server/protocol.def |  11 ++
 5 files changed, 324 insertions(+)
 create mode 100644 server/fsync.c
 create mode 100644 server/fsync.h

diff --git a/server/Makefile.in b/server/Makefile.in
index 9632c4e694f..4e2008a761f 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -15,6 +15,7 @@ SOURCES = \
 	event.c \
 	fd.c \
 	file.c \
+	fsync.c \
 	handle.c \
 	hook.c \
 	mach.c \
diff --git a/server/fsync.c b/server/fsync.c
new file mode 100644
index 00000000000..5f36e988803
--- /dev/null
+++ b/server/fsync.c
@@ -0,0 +1,286 @@
+/*
+ * futex-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <sys/mman.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+
+#include "handle.h"
+#include "request.h"
+#include "fsync.h"
+
+#include "pshpack4.h"
+struct futex_wait_block
+{
+    int *addr;
+#if __SIZEOF_POINTER__ == 4
+    int pad;
+#endif
+    int val;
+};
+#include "poppack.h"
+
+static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
+        int count, const struct timespec *timeout )
+{
+    return syscall( __NR_futex, futexes, 13, count, timeout, 0, 0 );
+}
+
+int do_fsync(void)
+{
+#ifdef __linux__
+    static int do_fsync_cached = -1;
+
+    if (do_fsync_cached == -1)
+    {
+        static const struct timespec zero;
+        futex_wait_multiple( NULL, 0, &zero );
+        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+    }
+
+    return do_fsync_cached;
+#else
+    return 0;
+#endif
+}
+
+static char shm_name[29];
+static int shm_fd;
+static off_t shm_size;
+static void **shm_addrs;
+static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+static long pagesize;
+
+static void shm_cleanup(void)
+{
+    close( shm_fd );
+    if (shm_unlink( shm_name ) == -1)
+        perror( "shm_unlink" );
+}
+
+void fsync_init(void)
+{
+    struct stat st;
+
+    if (fstat( config_dir_fd, &st ) == -1)
+        fatal_error( "cannot stat config dir\n" );
+
+    if (st.st_ino != (unsigned long)st.st_ino)
+        sprintf( shm_name, "/wine-%lx%08lx-fsync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
+    else
+        sprintf( shm_name, "/wine-%lx-fsync", (unsigned long)st.st_ino );
+
+    if (!shm_unlink( shm_name ))
+        fprintf( stderr, "fsync: warning: a previous shm file %s was not properly removed\n", shm_name );
+
+    shm_fd = shm_open( shm_name, O_RDWR | O_CREAT | O_EXCL, 0644 );
+    if (shm_fd == -1)
+        perror( "shm_open" );
+
+    pagesize = sysconf( _SC_PAGESIZE );
+
+    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
+    shm_addrs_size = 128;
+
+    shm_size = pagesize;
+    if (ftruncate( shm_fd, shm_size ) == -1)
+        perror( "ftruncate" );
+
+    atexit( shm_cleanup );
+}
+
+struct fsync
+{
+    struct object  obj;
+    unsigned int   shm_idx;
+};
+
+static void fsync_dump( struct object *obj, int verbose );
+static void fsync_destroy( struct object *obj );
+
+static const struct object_ops fsync_ops =
+{
+    sizeof(struct fsync),      /* size */
+    &no_type,                  /* type */
+    fsync_dump,                /* dump */
+    no_add_queue,              /* add_queue */
+    NULL,                      /* remove_queue */
+    NULL,                      /* signaled */
+    NULL,                      /* get_esync_fd */
+    NULL,                      /* satisfied */
+    no_signal,                 /* signal */
+    no_get_fd,                 /* get_fd */
+    default_map_access,        /* map_access */
+    default_get_sd,            /* get_sd */
+    default_set_sd,            /* set_sd */
+    default_get_full_name,     /* get_full_name */
+    no_lookup_name,            /* lookup_name */
+    directory_link_name,       /* link_name */
+    default_unlink_name,       /* unlink_name */
+    no_open_file,              /* open_file */
+    no_kernel_obj_list,        /* get_kernel_obj_list */
+    no_close_handle,           /* close_handle */
+    fsync_destroy              /* destroy */
+};
+
+static void fsync_dump( struct object *obj, int verbose )
+{
+    struct fsync *fsync = (struct fsync *)obj;
+    assert( obj->ops == &fsync_ops );
+    fprintf( stderr, "fsync idx=%d\n", fsync->shm_idx );
+}
+
+static void fsync_destroy( struct object *obj )
+{
+}
+
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+
+    if (entry >= shm_addrs_size)
+    {
+        int new_size = max(shm_addrs_size * 2, entry + 1);
+
+        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
+            fprintf( stderr, "fsync: couldn't expand shm_addrs array to size %d\n", entry + 1 );
+
+        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
+
+        shm_addrs_size = new_size;
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+        {
+            fprintf( stderr, "fsync: failed to map page %d (offset %#lx): ", entry, entry * pagesize );
+            perror( "mmap" );
+        }
+
+        if (debug_level)
+            fprintf( stderr, "fsync: Mapping page %d at %p.\n", entry, addr );
+
+        if (__sync_val_compare_and_swap( &shm_addrs[entry], 0, addr ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    return (void *)((unsigned long)shm_addrs[entry] + offset);
+}
+
+/* FIXME: This is rather inefficient... */
+static unsigned int shm_idx_counter = 1;
+
+struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
+                            unsigned int attr, int low, int high,
+                            const struct security_descriptor *sd )
+{
+#ifdef __linux__
+    struct fsync *fsync;
+
+    if ((fsync = create_named_object( root, &fsync_ops, name, attr, sd )))
+    {
+        if (get_error() != STATUS_OBJECT_NAME_EXISTS)
+        {
+            int *shm;
+
+            /* initialize it if it didn't already exist */
+
+            fsync->shm_idx = shm_idx_counter++;
+            while (fsync->shm_idx * 8 >= shm_size)
+            {
+                /* Better expand the shm section. */
+                shm_size += pagesize;
+                if (ftruncate( shm_fd, shm_size ) == -1)
+                {
+                    fprintf( stderr, "fsync: couldn't expand %s to size %lld: ",
+                        shm_name, (long long)shm_size );
+                    perror( "ftruncate" );
+                }
+            }
+
+            /* Initialize the shared memory portion. We want to do this on the
+             * server side to avoid a potential though unlikely race whereby
+             * the same object is opened and used between the time it's created
+             * and the time its shared memory portion is initialized. */
+
+            shm = get_shm( fsync->shm_idx );
+            assert(shm);
+            shm[0] = low;
+            shm[1] = high;
+        }
+    }
+
+    return fsync;
+#else
+    set_error( STATUS_NOT_IMPLEMENTED );
+    return NULL;
+#endif
+}
+
+DECL_HANDLER(create_fsync)
+{
+    struct fsync *fsync;
+    struct unicode_str name;
+    struct object *root;
+    const struct security_descriptor *sd;
+    const struct object_attributes *objattr = get_req_object_attributes( &sd, &name, &root );
+
+    if (!do_fsync())
+    {
+        set_error( STATUS_NOT_IMPLEMENTED );
+        return;
+    }
+
+    if (!objattr) return;
+
+    if ((fsync = create_fsync( root, &name, objattr->attributes, req->low,
+                               req->high, sd )))
+    {
+        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
+            reply->handle = alloc_handle( current->process, fsync, req->access, objattr->attributes );
+        else
+            reply->handle = alloc_handle_no_access_check( current->process, fsync,
+                                                          req->access, objattr->attributes );
+
+        reply->shm_idx = fsync->shm_idx;
+        release_object( fsync );
+    }
+
+    if (root) release_object( root );
+}
diff --git a/server/fsync.h b/server/fsync.h
new file mode 100644
index 00000000000..0b7e46cdaf3
--- /dev/null
+++ b/server/fsync.h
@@ -0,0 +1,22 @@
+/*
+ * futex-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+extern int do_fsync(void);
+extern void fsync_init(void);
diff --git a/server/main.c b/server/main.c
index 0073019113c..73d6318595e 100644
--- a/server/main.c
+++ b/server/main.c
@@ -35,6 +35,7 @@
 #include "request.h"
 #include "unicode.h"
 #include "esync.h"
+#include "fsync.h"
 
 /* command-line options */
 int debug_level = 0;
@@ -230,6 +231,9 @@ int main( int argc, char *argv[] )
     sock_init();
     open_master_socket();
 
+    if (do_fsync())
+        fsync_init();
+
     if (do_esync())
         esync_init();
 
diff --git a/server/protocol.def b/server/protocol.def
index fa162834359..39b29ed9658 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4004,3 +4004,14 @@ enum esync_type
 /* Retrieve the fd to wait on for user APCs. */
 @REQ(get_esync_apc_fd)
 @END
+
+/* Create a new futex-based synchronization object */
+@REQ(create_fsync)
+    unsigned int access;        /* wanted access rights */
+    int low;                    /* initial value of low word */
+    int high;                   /* initial value of high word */
+    VARARG(objattr,object_attributes); /* object attributes */
+@REPLY
+    obj_handle_t handle;        /* handle to the object */
+    unsigned int shm_idx;       /* this object's index into the shm section */
+@END
-- 
2.46.0


From 8bc80ccfb9a5cc5eff93b661da20731da1d09cac Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 6 Jul 2020 19:14:24 -0500
Subject: [PATCH 02/55] ntdll: Create futex-based objects for semaphores.

---
 dlls/ntdll/Makefile.in   |   1 +
 dlls/ntdll/unix/fsync.c  | 288 +++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h  |  25 ++++
 dlls/ntdll/unix/loader.c |   2 +
 dlls/ntdll/unix/sync.c   |   4 +
 5 files changed, 320 insertions(+)
 create mode 100644 dlls/ntdll/unix/fsync.c
 create mode 100644 dlls/ntdll/unix/fsync.h

diff --git a/dlls/ntdll/Makefile.in b/dlls/ntdll/Makefile.in
index 01a0cf4ab37..457ae577399 100644
--- a/dlls/ntdll/Makefile.in
+++ b/dlls/ntdll/Makefile.in
@@ -50,6 +50,7 @@ SOURCES = \
 	unix/env.c \
 	unix/esync.c \
 	unix/file.c \
+	unix/fsync.c \
 	unix/loader.c \
 	unix/loadorder.c \
 	unix/process.c \
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
new file mode 100644
index 00000000000..130f2f38b73
--- /dev/null
+++ b/dlls/ntdll/unix/fsync.c
@@ -0,0 +1,288 @@
+/*
+ * futex-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#ifdef HAVE_SYS_STAT_H
+# include <sys/stat.h>
+#endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
+#include <unistd.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winternl.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include "unix_private.h"
+#include "fsync.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(fsync);
+
+#include "pshpack4.h"
+struct futex_wait_block
+{
+    int *addr;
+#if __SIZEOF_POINTER__ == 4
+    int pad;
+#endif
+    int val;
+};
+#include "poppack.h"
+
+static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
+        int count, const struct timespec *timeout )
+{
+    return syscall( __NR_futex, futexes, 13, count, timeout, 0, 0 );
+}
+
+int do_fsync(void)
+{
+#ifdef __linux__
+    static int do_fsync_cached = -1;
+
+    if (do_fsync_cached == -1)
+    {
+        static const struct timespec zero;
+        futex_wait_multiple( NULL, 0, &zero );
+        do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+    }
+
+    return do_fsync_cached;
+#else
+    static int once;
+    if (!once++)
+        FIXME("futexes not supported on this platform.\n");
+    return 0;
+#endif
+}
+
+enum fsync_type
+{
+    FSYNC_SEMAPHORE = 1,
+};
+
+struct fsync
+{
+    enum fsync_type type;
+    void *shm;              /* pointer to shm section */
+};
+
+struct semaphore
+{
+    int count;
+    int max;
+};
+C_ASSERT(sizeof(struct semaphore) == 8);
+
+
+static char shm_name[29];
+static int shm_fd;
+static void **shm_addrs;
+static int shm_addrs_size;  /* length of the allocated shm_addrs array */
+static long pagesize;
+
+static void *get_shm( unsigned int idx )
+{
+    int entry  = (idx * 8) / pagesize;
+    int offset = (idx * 8) % pagesize;
+
+    if (entry >= shm_addrs_size)
+    {
+        int new_size = max(shm_addrs_size * 2, entry + 1);
+
+        if (!(shm_addrs = realloc( shm_addrs, new_size * sizeof(shm_addrs[0]) )))
+            ERR("Failed to grow shm_addrs array to size %d.\n", shm_addrs_size);
+        memset( shm_addrs + shm_addrs_size, 0, (new_size - shm_addrs_size) * sizeof(shm_addrs[0]) );
+        shm_addrs_size = new_size;
+    }
+
+    if (!shm_addrs[entry])
+    {
+        void *addr = mmap( NULL, pagesize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, entry * pagesize );
+        if (addr == (void *)-1)
+            ERR("Failed to map page %d (offset %#lx).\n", entry, entry * pagesize);
+
+        TRACE("Mapping page %d at %p.\n", entry, addr);
+
+        if (__sync_val_compare_and_swap( &shm_addrs[entry], 0, addr ))
+            munmap( addr, pagesize ); /* someone beat us to it */
+    }
+
+    return (void *)((unsigned long)shm_addrs[entry] + offset);
+}
+
+/* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
+ * This is copied and adapted from the fd cache code. */
+
+#define FSYNC_LIST_BLOCK_SIZE  (65536 / sizeof(struct fsync))
+#define FSYNC_LIST_ENTRIES     256
+
+static struct fsync *fsync_list[FSYNC_LIST_ENTRIES];
+static struct fsync fsync_list_initial_block[FSYNC_LIST_BLOCK_SIZE];
+
+static inline UINT_PTR handle_to_index( HANDLE handle, UINT_PTR *entry )
+{
+    UINT_PTR idx = (((UINT_PTR)handle) >> 2) - 1;
+    *entry = idx / FSYNC_LIST_BLOCK_SIZE;
+    return idx % FSYNC_LIST_BLOCK_SIZE;
+}
+
+static struct fsync *add_to_list( HANDLE handle, enum fsync_type type, void *shm )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    if (entry >= FSYNC_LIST_ENTRIES)
+    {
+        FIXME( "too many allocated handles, not caching %p\n", handle );
+        return FALSE;
+    }
+
+    if (!fsync_list[entry])  /* do we need to allocate a new block of entries? */
+    {
+        if (!entry) fsync_list[0] = fsync_list_initial_block;
+        else
+        {
+            void *ptr = anon_mmap_alloc( FSYNC_LIST_BLOCK_SIZE * sizeof(struct fsync),
+                                         PROT_READ | PROT_WRITE );
+            if (ptr == MAP_FAILED) return FALSE;
+            fsync_list[entry] = ptr;
+        }
+    }
+
+    if (!__sync_val_compare_and_swap((int *)&fsync_list[entry][idx].type, 0, type ))
+        fsync_list[entry][idx].shm = shm;
+
+    return &fsync_list[entry][idx];
+}
+
+static struct fsync *get_cached_object( HANDLE handle )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    if (entry >= FSYNC_LIST_ENTRIES || !fsync_list[entry]) return NULL;
+    if (!fsync_list[entry][idx].type) return NULL;
+
+    return &fsync_list[entry][idx];
+}
+
+static NTSTATUS create_fsync( enum fsync_type type, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int low, int high )
+{
+    NTSTATUS ret;
+    data_size_t len;
+    struct object_attributes *objattr;
+    unsigned int shm_idx;
+
+    if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
+
+    SERVER_START_REQ( create_fsync )
+    {
+        req->access = access;
+        req->low    = low;
+        req->high   = high;
+        wine_server_add_data( req, objattr, len );
+        ret = wine_server_call( req );
+        if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            shm_idx = reply->shm_idx;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
+    {
+        add_to_list( *handle, type, get_shm( shm_idx ));
+        TRACE("-> handle %p, shm index %d.\n", *handle, shm_idx);
+    }
+
+    free( objattr );
+    return ret;
+}
+
+void fsync_init(void)
+{
+    struct stat st;
+
+    if (!do_fsync())
+    {
+        /* make sure the server isn't running with WINEFSYNC */
+        HANDLE handle;
+        NTSTATUS ret;
+
+        ret = create_fsync( 0, &handle, 0, NULL, 0, 0 );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+        {
+            ERR("Server is running with WINEFSYNC but this process is not, please enable WINEFSYNC or restart wineserver.\n");
+            exit(1);
+        }
+
+        return;
+    }
+
+    if (stat( config_dir, &st ) == -1)
+        ERR("Cannot stat %s\n", config_dir);
+
+    if (st.st_ino != (unsigned long)st.st_ino)
+        sprintf( shm_name, "/wine-%lx%08lx-fsync", (unsigned long)((unsigned long long)st.st_ino >> 32), (unsigned long)st.st_ino );
+    else
+        sprintf( shm_name, "/wine-%lx-fsync", (unsigned long)st.st_ino );
+
+    if ((shm_fd = shm_open( shm_name, O_RDWR, 0644 )) == -1)
+    {
+        /* probably the server isn't running with WINEFSYNC, tell the user and bail */
+        if (errno == ENOENT)
+            ERR("Failed to open fsync shared memory file; make sure no stale wineserver instances are running without WINEFSYNC.\n");
+        else
+            ERR("Failed to initialize shared memory: %s\n", strerror( errno ));
+        exit(1);
+    }
+
+    pagesize = sysconf( _SC_PAGESIZE );
+
+    shm_addrs = calloc( 128, sizeof(shm_addrs[0]) );
+    shm_addrs_size = 128;
+}
+
+NTSTATUS fsync_create_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max )
+{
+    TRACE("name %s, initial %d, max %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>", (int)initial, (int)max);
+
+    return create_fsync( FSYNC_SEMAPHORE, handle, access, attr, initial, max );
+}
+
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
new file mode 100644
index 00000000000..273a4817dd0
--- /dev/null
+++ b/dlls/ntdll/unix/fsync.h
@@ -0,0 +1,25 @@
+/*
+ * futex-based synchronization objects
+ *
+ * Copyright (C) 2018 Zebediah Figura
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+extern int do_fsync(void);
+extern void fsync_init(void);
+
+extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max);
diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index fefe50e7511..ccbd08b01e6 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -91,6 +91,7 @@
 #include "winternl.h"
 #include "unix_private.h"
 #include "esync.h"
+#include "fsync.h"
 #include "wine/list.h"
 #include "ntsyscalls.h"
 #include "wine/debug.h"
@@ -1859,6 +1860,7 @@ static void start_main_thread(void)
     signal_alloc_thread( teb );
     dbg_init();
     startup_info_size = server_init_process();
+    fsync_init();
     esync_init();
     virtual_map_user_shared_data();
     init_cpu_info();
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index a52327841d2..540d6fe40d2 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -67,6 +67,7 @@
 #include "wine/debug.h"
 #include "unix_private.h"
 #include "esync.h"
+#include "fsync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(sync);
 
@@ -320,6 +321,9 @@ NTSTATUS WINAPI NtCreateSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJ
     if (max <= 0 || initial < 0 || initial > max) return STATUS_INVALID_PARAMETER;
     if ((ret = alloc_object_attributes( attr, &objattr, &len ))) return ret;
 
+    if (do_fsync())
+        return fsync_create_semaphore( handle, access, attr, initial, max );
+
     if (do_esync())
         return esync_create_semaphore( handle, access, attr, initial, max );
 
-- 
2.46.0


From 09b4bccc09a486fd8449cad3071a374943a416a2 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 6 Jul 2020 19:21:55 -0500
Subject: [PATCH 03/55] ntdll: Implement NtReleaseSemaphore().

---
 dlls/ntdll/unix/fsync.c | 30 ++++++++++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 server/esync.c          |  1 +
 4 files changed, 35 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 130f2f38b73..5281d1cbce8 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -68,6 +68,11 @@ static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
     return syscall( __NR_futex, futexes, 13, count, timeout, 0, 0 );
 }
 
+static inline int futex_wake( int *addr, int val )
+{
+    return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
+}
+
 int do_fsync(void)
 {
 #ifdef __linux__
@@ -286,3 +291,28 @@ NTSTATUS fsync_create_semaphore( HANDLE *handle, ACCESS_MASK access,
     return create_fsync( FSYNC_SEMAPHORE, handle, access, attr, initial, max );
 }
 
+NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
+{
+    struct fsync *obj;
+    struct semaphore *semaphore;
+    ULONG current;
+
+    TRACE("%p, %d, %p.\n", handle, (int)count, prev);
+
+    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    semaphore = obj->shm;
+
+    do
+    {
+        current = semaphore->count;
+        if (count + current > semaphore->max)
+            return STATUS_SEMAPHORE_LIMIT_EXCEEDED;
+    } while (__sync_val_compare_and_swap( &semaphore->count, current, count + current ) != current);
+
+    if (prev) *prev = current;
+
+    if (!current)
+        futex_wake( &semaphore->count, count );
+
+    return STATUS_SUCCESS;
+}
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 273a4817dd0..0ec618385ed 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -23,3 +23,4 @@ extern void fsync_init(void);
 
 extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max);
+extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 540d6fe40d2..27910f77325 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -416,6 +416,9 @@ NTSTATUS WINAPI NtReleaseSemaphore( HANDLE handle, ULONG count, ULONG *previous
 {
     unsigned int ret;
 
+    if (do_fsync())
+        return fsync_release_semaphore( handle, count, previous );
+
     if (do_esync())
         return esync_release_semaphore( handle, count, previous );
 
diff --git a/server/esync.c b/server/esync.c
index e193f61b3a7..fc8120f9449 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -23,6 +23,7 @@
 
 #include <fcntl.h>
 #include <stdio.h>
+#include <stdint.h>
 #include <stdarg.h>
 #ifdef HAVE_SYS_EVENTFD_H
 # include <sys/eventfd.h>
-- 
2.46.0


From 860c0698f9c8f098895a56bef5aa26df4a1a7d9f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 15:50:37 -0500
Subject: [PATCH 04/55] ntdll: Close fsync objects.

---
 dlls/ntdll/unix/fsync.c  | 15 +++++++++++++++
 dlls/ntdll/unix/fsync.h  |  1 +
 dlls/ntdll/unix/server.c |  4 ++++
 3 files changed, 20 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 5281d1cbce8..2f199286950 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -203,6 +203,21 @@ static struct fsync *get_cached_object( HANDLE handle )
     return &fsync_list[entry][idx];
 }
 
+NTSTATUS fsync_close( HANDLE handle )
+{
+    UINT_PTR entry, idx = handle_to_index( handle, &entry );
+
+    TRACE("%p.\n", handle);
+
+    if (entry < FSYNC_LIST_ENTRIES && fsync_list[entry])
+    {
+        if (__atomic_exchange_n( &fsync_list[entry][idx].type, 0, __ATOMIC_SEQ_CST ))
+            return STATUS_SUCCESS;
+    }
+
+    return STATUS_INVALID_HANDLE;
+}
+
 static NTSTATUS create_fsync( enum fsync_type type, HANDLE *handle,
     ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr, int low, int high )
 {
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 0ec618385ed..ed10eeb2d7b 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -20,6 +20,7 @@
 
 extern int do_fsync(void);
 extern void fsync_init(void);
+extern NTSTATUS fsync_close( HANDLE handle );
 
 extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max);
diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index 57d0f6e51da..eba8a82c932 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -80,6 +80,7 @@
 #include "wine/debug.h"
 #include "unix_private.h"
 #include "esync.h"
+#include "fsync.h"
 #include "ddk/wdm.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
@@ -1831,6 +1832,9 @@ NTSTATUS WINAPI NtClose( HANDLE handle )
      * retrieve it again */
     fd = remove_fd_from_cache( handle );
 
+    if (do_fsync())
+        fsync_close( handle );
+
     if (do_esync())
         esync_close( handle );
 
-- 
2.46.0


From 6a636a2e15fee7daf292b5f35284c80e9a21fdc8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:25:59 -0500
Subject: [PATCH 05/55] ntdll: Implement waiting on fsync objects.

---
 dlls/ntdll/unix/fsync.c | 145 ++++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |   3 +
 dlls/ntdll/unix/sync.c  |   7 ++
 3 files changed, 155 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2f199286950..504806ae10a 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -331,3 +331,148 @@ NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 
     return STATUS_SUCCESS;
 }
+
+static LONGLONG update_timeout( ULONGLONG end )
+{
+    LARGE_INTEGER now;
+    LONGLONG timeleft;
+
+    NtQuerySystemTime( &now );
+    timeleft = end - now.QuadPart;
+    if (timeleft < 0) timeleft = 0;
+    return timeleft;
+}
+
+NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
+    BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    struct futex_wait_block futexes[MAXIMUM_WAIT_OBJECTS];
+    struct fsync *objs[MAXIMUM_WAIT_OBJECTS];
+    int has_fsync = 0, has_server = 0;
+    int dummy_futex = 0;
+    LONGLONG timeleft;
+    LARGE_INTEGER now;
+    ULONGLONG end;
+    int i, ret;
+
+    NtQuerySystemTime( &now );
+    if (timeout)
+    {
+        if (timeout->QuadPart == TIMEOUT_INFINITE)
+            timeout = NULL;
+        else if (timeout->QuadPart > 0)
+            end = timeout->QuadPart;
+        else
+            end = now.QuadPart - timeout->QuadPart;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        if ((objs[i] = get_cached_object( handles[i] )))
+            has_fsync = 1;
+        else
+            has_server = 1;
+    }
+
+    if (has_fsync && has_server)
+        FIXME("Can't wait on fsync and server objects at the same time!\n");
+    else if (has_server)
+        return STATUS_NOT_IMPLEMENTED;
+
+    if (TRACE_ON(fsync))
+    {
+        TRACE("Waiting for %s of %d handles:", wait_any ? "any" : "all", (int)count);
+        for (i = 0; i < count; i++)
+            TRACE(" %p", handles[i]);
+
+        if (!timeout)
+            TRACE(", timeout = INFINITE.\n");
+        else
+        {
+            timeleft = update_timeout( end );
+            TRACE(", timeout = %ld.%07ld sec.\n",
+                (long) (timeleft / TICKSPERSEC), (long) (timeleft % TICKSPERSEC));
+        }
+    }
+
+    if (wait_any || count == 1)
+    {
+        while (1)
+        {
+            /* Try to grab anything. */
+
+            for (i = 0; i < count; i++)
+            {
+                struct fsync *obj = objs[i];
+
+                if (obj)
+                {
+                    switch (obj->type)
+                    {
+                    case FSYNC_SEMAPHORE:
+                    {
+                        struct semaphore *semaphore = obj->shm;
+                        int current;
+
+                        do
+                        {
+                            if (!(current = semaphore->count)) break;
+                        } while (__sync_val_compare_and_swap( &semaphore->count, current, current - 1 ) != current);
+
+                        if (current)
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            return i;
+                        }
+
+                        futexes[i].addr = &semaphore->count;
+                        futexes[i].val = current;
+                        break;
+                    }
+                    default:
+                        assert(0);
+                    }
+                }
+                else
+                {
+                    /* Avoid breaking things entirely. */
+                    futexes[i].addr = &dummy_futex;
+                    futexes[i].val = dummy_futex;
+                }
+
+#if __SIZEOF_POINTER__ == 4
+                futexes[i].pad = 0;
+#endif
+            }
+
+            /* Looks like everything is contended, so wait. */
+
+            if (timeout)
+            {
+                LONGLONG timeleft = update_timeout( end );
+                struct timespec tmo_p;
+                tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+                tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+
+                ret = futex_wait_multiple( futexes, count, &tmo_p );
+            }
+            else
+                ret = futex_wait_multiple( futexes, count, NULL );
+
+            /* FUTEX_WAIT_MULTIPLE can succeed or return -EINTR, -EAGAIN,
+             * -EFAULT/-EACCES, -ETIMEDOUT. In the first three cases we need to
+             * try again, bad address is already handled by the fact that we
+             * tried to read from it, so only break out on a timeout. */
+            if (ret == -1 && errno == ETIMEDOUT)
+            {
+                TRACE("Wait timed out.\n");
+                return STATUS_TIMEOUT;
+            }
+        } /* while (1) */
+    }
+    else
+    {
+        FIXME("Wait-all not implemented.\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+}
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index ed10eeb2d7b..4a5c00ca0a7 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -25,3 +25,6 @@ extern NTSTATUS fsync_close( HANDLE handle );
 extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max);
 extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev );
+
+extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                                    BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 27910f77325..35596cc81c9 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1637,6 +1637,13 @@ NTSTATUS WINAPI NtWaitForMultipleObjects( DWORD count, const HANDLE *handles, BO
 
     if (!count || count > MAXIMUM_WAIT_OBJECTS) return STATUS_INVALID_PARAMETER_1;
 
+    if (do_fsync())
+    {
+        NTSTATUS ret = fsync_wait_objects( count, handles, wait_any, alertable, timeout );
+        if (ret != STATUS_NOT_IMPLEMENTED)
+            return ret;
+    }
+
     if (do_esync())
     {
         NTSTATUS ret = esync_wait_objects( count, handles, wait_any, alertable, timeout );
-- 
2.46.0


From 83be85d91c432143b731fba916a155c1df46ab4c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:31:54 -0500
Subject: [PATCH 06/55] ntdll: Create fsync objects for events.

---
 dlls/ntdll/unix/fsync.c | 20 ++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  2 ++
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 25 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 504806ae10a..2a7dee5f661 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -97,6 +97,8 @@ int do_fsync(void)
 enum fsync_type
 {
     FSYNC_SEMAPHORE = 1,
+    FSYNC_AUTO_EVENT,
+    FSYNC_MANUAL_EVENT,
 };
 
 struct fsync
@@ -112,6 +114,12 @@ struct semaphore
 };
 C_ASSERT(sizeof(struct semaphore) == 8);
 
+struct event
+{
+    int signaled;
+    int unused;
+};
+C_ASSERT(sizeof(struct event) == 8);
 
 static char shm_name[29];
 static int shm_fd;
@@ -332,6 +340,18 @@ NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
+{
+    enum fsync_type type = (event_type == SynchronizationEvent ? FSYNC_AUTO_EVENT : FSYNC_MANUAL_EVENT);
+
+    TRACE("name %s, %s-reset, initial %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>",
+        event_type == NotificationEvent ? "manual" : "auto", initial);
+
+    return create_fsync( type, handle, access, attr, initial, 0xdeadbeef );
+}
+
 static LONGLONG update_timeout( ULONGLONG end )
 {
     LARGE_INTEGER now;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 4a5c00ca0a7..cc93044f38f 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -25,6 +25,8 @@ extern NTSTATUS fsync_close( HANDLE handle );
 extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max);
 extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev );
+extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 35596cc81c9..063a4a455eb 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -449,6 +449,9 @@ NTSTATUS WINAPI NtCreateEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_
     *handle = 0;
     if (type != NotificationEvent && type != SynchronizationEvent) return STATUS_INVALID_PARAMETER;
 
+    if (do_fsync())
+        return fsync_create_event( handle, access, attr, type, state );
+
     if (do_esync())
         return esync_create_event( handle, access, attr, type, state );
 
-- 
2.46.0


From 75ef37d650ec0ab4d1a3832509cae23b4827daf9 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:36:16 -0500
Subject: [PATCH 07/55] ntdll: Implement NtSetEvent().

---
 dlls/ntdll/unix/fsync.c | 20 ++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 24 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2a7dee5f661..a8c364162cc 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -352,6 +353,25 @@ NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     return create_fsync( type, handle, access, attr, initial, 0xdeadbeef );
 }
 
+NTSTATUS fsync_set_event( HANDLE handle, LONG *prev )
+{
+    struct event *event;
+    struct fsync *obj;
+    LONG current;
+
+    TRACE("%p.\n", handle);
+
+    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    event = obj->shm;
+
+    if (!(current = __atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST )))
+        futex_wake( &event->signaled, obj->type == FSYNC_AUTO_EVENT ? 1 : INT_MAX );
+
+    if (prev) *prev = current;
+
+    return STATUS_SUCCESS;
+}
+
 static LONGLONG update_timeout( ULONGLONG end )
 {
     LARGE_INTEGER now;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index cc93044f38f..2ba03261c17 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -27,6 +27,7 @@ extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
 extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev );
 extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
+extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 063a4a455eb..ab2835c1017 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -509,6 +509,9 @@ NTSTATUS WINAPI NtSetEvent( HANDLE handle, LONG *prev_state )
     /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
+    if (do_fsync())
+        return fsync_set_event( handle, prev_state );
+
     if (do_esync())
         return esync_set_event( handle );
 
-- 
2.46.0


From 4bf7295702772f11e131cb0573a3c39b21ae63d6 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:39:38 -0500
Subject: [PATCH 08/55] ntdll: Implement NtResetEvent().

---
 dlls/ntdll/unix/fsync.c | 18 ++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 22 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index a8c364162cc..c7b4ee1a298 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -372,6 +372,24 @@ NTSTATUS fsync_set_event( HANDLE handle, LONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev )
+{
+    struct event *event;
+    struct fsync *obj;
+    LONG current;
+
+    TRACE("%p.\n", handle);
+
+    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    event = obj->shm;
+
+    current = __atomic_exchange_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
+
+    if (prev) *prev = current;
+
+    return STATUS_SUCCESS;
+}
+
 static LONGLONG update_timeout( ULONGLONG end )
 {
     LARGE_INTEGER now;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 2ba03261c17..56afeb1f9e8 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -28,6 +28,7 @@ extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev
 extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
 extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
+extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index ab2835c1017..1404a28f395 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -535,6 +535,9 @@ NTSTATUS WINAPI NtResetEvent( HANDLE handle, LONG *prev_state )
     /* This comment is a dummy to make sure this patch applies in the right place. */
     unsigned int ret;
 
+    if (do_fsync())
+        return fsync_reset_event( handle, prev_state );
+
     if (do_esync())
         return esync_reset_event( handle );
 
-- 
2.46.0


From a6a6c5804d69fb74c0fe3f54756e416ddf228c40 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:45:43 -0500
Subject: [PATCH 09/55] ntdll: Implement waiting on events.

---
 dlls/ntdll/unix/fsync.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index c7b4ee1a298..e7a495be365 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -487,6 +487,34 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
                         futexes[i].val = current;
                         break;
                     }
+                    case FSYNC_AUTO_EVENT:
+                    {
+                        struct event *event = obj->shm;
+
+                        if (__sync_val_compare_and_swap( &event->signaled, 1, 0 ))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            return i;
+                        }
+
+                        futexes[i].addr = &event->signaled;
+                        futexes[i].val = 0;
+                        break;
+                    }
+                    case FSYNC_MANUAL_EVENT:
+                    {
+                        struct event *event = obj->shm;
+
+                        if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            return i;
+                        }
+
+                        futexes[i].addr = &event->signaled;
+                        futexes[i].val = 0;
+                        break;
+                    }
                     default:
                         assert(0);
                     }
-- 
2.46.0


From 8c2b285960adb329511067b40209fb28f9d9eefc Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:52:01 -0500
Subject: [PATCH 10/55] server: Add an object operation to grab the fsync shm
 index.

---
 server/async.c      | 2 ++
 server/atom.c       | 1 +
 server/change.c     | 1 +
 server/clipboard.c  | 1 +
 server/completion.c | 1 +
 server/console.c    | 7 +++++++
 server/debugger.c   | 2 ++
 server/device.c     | 4 ++++
 server/directory.c  | 2 ++
 server/esync.c      | 1 +
 server/event.c      | 2 ++
 server/fd.c         | 4 ++++
 server/file.c       | 1 +
 server/fsync.c      | 1 +
 server/handle.c     | 1 +
 server/hook.c       | 1 +
 server/mailslot.c   | 4 ++++
 server/mapping.c    | 3 +++
 server/mutex.c      | 1 +
 server/named_pipe.c | 5 +++++
 server/object.h     | 2 ++
 server/process.c    | 3 +++
 server/queue.c      | 2 ++
 server/registry.c   | 1 +
 server/request.c    | 1 +
 server/semaphore.c  | 1 +
 server/serial.c     | 1 +
 server/signal.c     | 1 +
 server/sock.c       | 3 +++
 server/symlink.c    | 1 +
 server/thread.c     | 3 +++
 server/timer.c      | 1 +
 server/token.c      | 1 +
 server/window.c     | 1 +
 server/winstation.c | 2 ++
 35 files changed, 69 insertions(+)

diff --git a/server/async.c b/server/async.c
index bea720b1f19..9eaaf8d18e2 100644
--- a/server/async.c
+++ b/server/async.c
@@ -78,6 +78,7 @@ static const struct object_ops async_ops =
     remove_queue,              /* remove_queue */
     async_signaled,            /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     async_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -688,6 +689,7 @@ static const struct object_ops iosb_ops =
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
     NULL,                     /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/atom.c b/server/atom.c
index d9824de8eac..6b95a546597 100644
--- a/server/atom.c
+++ b/server/atom.c
@@ -80,6 +80,7 @@ static const struct object_ops atom_table_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/change.c b/server/change.c
index bd72bdefdf4..215db47f11e 100644
--- a/server/change.c
+++ b/server/change.c
@@ -113,6 +113,7 @@ static const struct object_ops dir_ops =
     remove_queue,             /* remove_queue */
     default_fd_signaled,      /* signaled */
     default_fd_get_esync_fd,  /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     no_satisfied,             /* satisfied */
     no_signal,                /* signal */
     dir_get_fd,               /* get_fd */
diff --git a/server/clipboard.c b/server/clipboard.c
index 8b265f2dcea..f24924eafa5 100644
--- a/server/clipboard.c
+++ b/server/clipboard.c
@@ -77,6 +77,7 @@ static const struct object_ops clipboard_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/completion.c b/server/completion.c
index 3d4be86a212..33266c596da 100644
--- a/server/completion.c
+++ b/server/completion.c
@@ -76,6 +76,7 @@ static const struct object_ops completion_ops =
     remove_queue,              /* remove_queue */
     completion_signaled,       /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/console.c b/server/console.c
index dbd4a97459c..43248d359ca 100644
--- a/server/console.c
+++ b/server/console.c
@@ -83,6 +83,7 @@ static const struct object_ops console_ops =
     remove_queue,                     /* remove_queue */
     console_signaled,                 /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_get_fd,                   /* get_fd */
@@ -163,6 +164,7 @@ static const struct object_ops console_server_ops =
     remove_queue,                     /* remove_queue */
     console_server_signaled,          /* signaled */
     console_server_get_esync_fd,      /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_server_get_fd,            /* get_fd */
@@ -233,6 +235,7 @@ static const struct object_ops screen_buffer_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     NULL,                             /* satisfied */
     no_signal,                        /* signal */
     screen_buffer_get_fd,             /* get_fd */
@@ -283,6 +286,7 @@ static const struct object_ops console_device_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -321,6 +325,7 @@ static const struct object_ops console_input_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_input_get_fd,             /* get_fd */
@@ -379,6 +384,7 @@ static const struct object_ops console_output_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_output_get_fd,            /* get_fd */
@@ -438,6 +444,7 @@ static const struct object_ops console_connection_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     console_connection_get_fd,        /* get_fd */
diff --git a/server/debugger.c b/server/debugger.c
index ca04d4c71ce..39e144062be 100644
--- a/server/debugger.c
+++ b/server/debugger.c
@@ -87,6 +87,7 @@ static const struct object_ops debug_event_ops =
     remove_queue,                  /* remove_queue */
     debug_event_signaled,          /* signaled */
     NULL,                          /* get_esync_fd */
+    NULL,                          /* get_fsync_idx */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -116,6 +117,7 @@ static const struct object_ops debug_obj_ops =
     remove_queue,                  /* remove_queue */
     debug_obj_signaled,            /* signaled */
     NULL,                          /* get_esync_fd */
+    NULL,                          /* get_fsync_idx */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/device.c b/server/device.c
index c45d0102a56..8613cee58af 100644
--- a/server/device.c
+++ b/server/device.c
@@ -69,6 +69,7 @@ static const struct object_ops irp_call_ops =
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
     NULL,                             /* satisfied */
+    NULL,                             /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
     default_map_access,               /* map_access */
@@ -111,6 +112,7 @@ static const struct object_ops device_manager_ops =
     remove_queue,                     /* remove_queue */
     device_manager_signaled,          /* signaled */
     device_manager_get_esync_fd,      /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -169,6 +171,7 @@ static const struct object_ops device_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -222,6 +225,7 @@ static const struct object_ops device_file_ops =
     remove_queue,                     /* remove_queue */
     default_fd_signaled,              /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     device_file_get_fd,               /* get_fd */
diff --git a/server/directory.c b/server/directory.c
index 1c44ded4606..968971336ce 100644
--- a/server/directory.c
+++ b/server/directory.c
@@ -70,6 +70,7 @@ static const struct object_ops object_type_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -121,6 +122,7 @@ static const struct object_ops directory_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/esync.c b/server/esync.c
index fc8120f9449..064bdd61b25 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -129,6 +129,7 @@ const struct object_ops esync_ops =
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
     esync_get_esync_fd,        /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/event.c b/server/event.c
index f4ca3e48c6f..f5a25c02293 100644
--- a/server/event.c
+++ b/server/event.c
@@ -77,6 +77,7 @@ static const struct object_ops event_ops =
     remove_queue,              /* remove_queue */
     event_signaled,            /* signaled */
     event_get_esync_fd,        /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -125,6 +126,7 @@ static const struct object_ops keyed_event_ops =
     remove_queue,                /* remove_queue */
     keyed_event_signaled,        /* signaled */
     NULL,                        /* get_esync_fd */
+    NULL,                        /* get_fsync_idx */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
diff --git a/server/fd.c b/server/fd.c
index f70c6edf68b..509f0b42534 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -172,6 +172,7 @@ static const struct object_ops fd_ops =
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
     NULL,                     /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -214,6 +215,7 @@ static const struct object_ops device_ops =
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
     NULL,                     /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -255,6 +257,7 @@ static const struct object_ops inode_ops =
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
     NULL,                     /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
@@ -298,6 +301,7 @@ static const struct object_ops file_lock_ops =
     remove_queue,               /* remove_queue */
     file_lock_signaled,         /* signaled */
     NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
diff --git a/server/file.c b/server/file.c
index 26c62809d33..5be9578ce48 100644
--- a/server/file.c
+++ b/server/file.c
@@ -95,6 +95,7 @@ static const struct object_ops file_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     file_get_fd,                  /* get_fd */
diff --git a/server/fsync.c b/server/fsync.c
index 5f36e988803..55a8e709dbf 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -140,6 +140,7 @@ static const struct object_ops fsync_ops =
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/handle.c b/server/handle.c
index 7fc24d12a34..5c9530709e1 100644
--- a/server/handle.c
+++ b/server/handle.c
@@ -127,6 +127,7 @@ static const struct object_ops handle_table_ops =
     NULL,                            /* remove_queue */
     NULL,                            /* signaled */
     NULL,                            /* get_esync_fd */
+    NULL,                            /* get_fsync_idx */
     NULL,                            /* satisfied */
     no_signal,                       /* signal */
     no_get_fd,                       /* get_fd */
diff --git a/server/hook.c b/server/hook.c
index ab4d0e9dd31..e40ccb74361 100644
--- a/server/hook.c
+++ b/server/hook.c
@@ -82,6 +82,7 @@ static const struct object_ops hook_table_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/mailslot.c b/server/mailslot.c
index a8258328364..dde3e69e0c3 100644
--- a/server/mailslot.c
+++ b/server/mailslot.c
@@ -82,6 +82,7 @@ static const struct object_ops mailslot_ops =
     remove_queue,              /* remove_queue */
     default_fd_signaled,       /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     no_satisfied,              /* satisfied */
     no_signal,                 /* signal */
     mailslot_get_fd,           /* get_fd */
@@ -144,6 +145,7 @@ static const struct object_ops mail_writer_ops =
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
     NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
     NULL,                       /* satisfied */
     no_signal,                  /* signal */
     mail_writer_get_fd,         /* get_fd */
@@ -210,6 +212,7 @@ static const struct object_ops mailslot_device_ops =
     NULL,                           /* remove_queue */
     NULL,                           /* signaled */
     NULL,                           /* get_esync_fd */
+    NULL,                           /* get_fsync_idx */
     no_satisfied,                   /* satisfied */
     no_signal,                      /* signal */
     no_get_fd,                      /* get_fd */
@@ -241,6 +244,7 @@ static const struct object_ops mailslot_device_file_ops =
     remove_queue,                           /* remove_queue */
     default_fd_signaled,                    /* signaled */
     NULL,                                   /* get_esync_fd */
+    NULL,                                   /* get_fsync_idx */
     no_satisfied,                           /* satisfied */
     no_signal,                              /* signal */
     mailslot_device_file_get_fd,            /* get_fd */
diff --git a/server/mapping.c b/server/mapping.c
index bdb9ee5d840..2fc2bec3adc 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -68,6 +68,7 @@ static const struct object_ops ranges_ops =
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -105,6 +106,7 @@ static const struct object_ops shared_map_ops =
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -179,6 +181,7 @@ static const struct object_ops mapping_ops =
     NULL,                        /* remove_queue */
     NULL,                        /* signaled */
     NULL,                        /* get_esync_fd */
+    NULL,                        /* get_fsync_idx */
     NULL,                        /* satisfied */
     no_signal,                   /* signal */
     mapping_get_fd,              /* get_fd */
diff --git a/server/mutex.c b/server/mutex.c
index 4785a830e92..2503d12057f 100644
--- a/server/mutex.c
+++ b/server/mutex.c
@@ -74,6 +74,7 @@ static const struct object_ops mutex_ops =
     remove_queue,              /* remove_queue */
     mutex_signaled,            /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     mutex_satisfied,           /* satisfied */
     mutex_signal,              /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 8ba8126563a..0ad89f869f6 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -120,6 +120,7 @@ static const struct object_ops named_pipe_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -169,6 +170,7 @@ static const struct object_ops pipe_server_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     default_fd_get_esync_fd,      /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -214,6 +216,7 @@ static const struct object_ops pipe_client_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     default_fd_get_esync_fd,      /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -262,6 +265,7 @@ static const struct object_ops named_pipe_device_ops =
     NULL,                             /* remove_queue */
     NULL,                             /* signaled */
     NULL,                             /* get_esync_fd */
+    NULL,                             /* get_fsync_idx */
     no_satisfied,                     /* satisfied */
     no_signal,                        /* signal */
     no_get_fd,                        /* get_fd */
@@ -294,6 +298,7 @@ static const struct object_ops named_pipe_device_file_ops =
     remove_queue,                            /* remove_queue */
     default_fd_signaled,                     /* signaled */
     NULL,                                    /* get_esync_fd */
+    NULL,                                    /* get_fsync_idx */
     no_satisfied,                            /* satisfied */
     no_signal,                               /* signal */
     named_pipe_device_file_get_fd,           /* get_fd */
diff --git a/server/object.h b/server/object.h
index 0c85536def4..d8f027275db 100644
--- a/server/object.h
+++ b/server/object.h
@@ -80,6 +80,8 @@ struct object_ops
     int  (*signaled)(struct object *,struct wait_queue_entry *);
     /* return the esync fd for this object */
     int (*get_esync_fd)(struct object *, enum esync_type *type);
+    /* return the fsync shm idx for this object */
+    unsigned int (*get_fsync_idx)(struct object *);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
     /* signal an object */
diff --git a/server/process.c b/server/process.c
index ce34f46166a..ea7da2db209 100644
--- a/server/process.c
+++ b/server/process.c
@@ -108,6 +108,7 @@ static const struct object_ops process_ops =
     remove_queue,                /* remove_queue */
     process_signaled,            /* signaled */
     process_get_esync_fd,        /* get_esync_fd */
+    NULL,                        /* get_fsync_idx */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -160,6 +161,7 @@ static const struct object_ops startup_info_ops =
     remove_queue,                  /* remove_queue */
     startup_info_signaled,         /* signaled */
     NULL,                          /* get_esync_fd */
+    NULL,                          /* get_fsync_idx */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
@@ -222,6 +224,7 @@ static const struct object_ops job_ops =
     remove_queue,                  /* remove_queue */
     job_signaled,                  /* signaled */
     NULL,                          /* get_esync_fd */
+    NULL,                          /* get_fsync_idx */
     no_satisfied,                  /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/queue.c b/server/queue.c
index 7d3c3061700..64b77f331fa 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -169,6 +169,7 @@ static const struct object_ops msg_queue_ops =
     msg_queue_remove_queue,    /* remove_queue */
     msg_queue_signaled,        /* signaled */
     msg_queue_get_esync_fd,    /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -207,6 +208,7 @@ static const struct object_ops thread_input_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/registry.c b/server/registry.c
index 0bb8ec4b5fb..b2fba4c004f 100644
--- a/server/registry.c
+++ b/server/registry.c
@@ -181,6 +181,7 @@ static const struct object_ops key_ops =
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
     NULL,                    /* get_esync_fd */
+    NULL,                    /* get_fsync_idx */
     NULL,                    /* satisfied */
     no_signal,               /* signal */
     no_get_fd,               /* get_fd */
diff --git a/server/request.c b/server/request.c
index 8e7d88a0d4c..6e08ef43b33 100644
--- a/server/request.c
+++ b/server/request.c
@@ -91,6 +91,7 @@ static const struct object_ops master_socket_ops =
     NULL,                          /* remove_queue */
     NULL,                          /* signaled */
     NULL,                          /* get_esync_fd */
+    NULL,                          /* get_fsync_idx */
     NULL,                          /* satisfied */
     no_signal,                     /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/semaphore.c b/server/semaphore.c
index e3889f24601..d354892c224 100644
--- a/server/semaphore.c
+++ b/server/semaphore.c
@@ -71,6 +71,7 @@ static const struct object_ops semaphore_ops =
     remove_queue,                  /* remove_queue */
     semaphore_signaled,            /* signaled */
     NULL,                          /* get_esync_fd */
+    NULL,                          /* get_fsync_idx */
     semaphore_satisfied,           /* satisfied */
     semaphore_signal,              /* signal */
     no_get_fd,                     /* get_fd */
diff --git a/server/serial.c b/server/serial.c
index 0d49a996c2a..2d9b2cd5318 100644
--- a/server/serial.c
+++ b/server/serial.c
@@ -92,6 +92,7 @@ static const struct object_ops serial_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     serial_get_fd,                /* get_fd */
diff --git a/server/signal.c b/server/signal.c
index 55cd6aa037e..802b7f936b9 100644
--- a/server/signal.c
+++ b/server/signal.c
@@ -63,6 +63,7 @@ static const struct object_ops handler_ops =
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
     NULL,                     /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/sock.c b/server/sock.c
index 1937bb280da..430790a6409 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -454,6 +454,7 @@ static const struct object_ops sock_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     sock_get_fd,                  /* get_fd */
@@ -3583,6 +3584,7 @@ static const struct object_ops ifchange_ops =
     NULL,                    /* remove_queue */
     NULL,                    /* signaled */
     NULL,                    /* get_esync_fd */
+    NULL,                    /* get_fsync_idx */
     no_satisfied,            /* satisfied */
     no_signal,               /* signal */
     ifchange_get_fd,         /* get_fd */
@@ -3805,6 +3807,7 @@ static const struct object_ops socket_device_ops =
     NULL,                       /* remove_queue */
     NULL,                       /* signaled */
     NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
diff --git a/server/symlink.c b/server/symlink.c
index c7f34412317..47098fe5823 100644
--- a/server/symlink.c
+++ b/server/symlink.c
@@ -72,6 +72,7 @@ static const struct object_ops symlink_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
diff --git a/server/thread.c b/server/thread.c
index 2609e4e3d9e..f652e2d6813 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -98,6 +98,7 @@ static const struct object_ops thread_apc_ops =
     remove_queue,               /* remove_queue */
     thread_apc_signaled,        /* signaled */
     NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -141,6 +142,7 @@ static const struct object_ops context_ops =
     remove_queue,               /* remove_queue */
     context_signaled,           /* signaled */
     NULL,                       /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -192,6 +194,7 @@ static const struct object_ops thread_ops =
     remove_queue,               /* remove_queue */
     thread_signaled,            /* signaled */
     thread_get_esync_fd,        /* get_esync_fd */
+    NULL,                       /* get_fsync_idx */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
diff --git a/server/timer.c b/server/timer.c
index 36645a2a8d2..9ec9604aa0e 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -80,6 +80,7 @@ static const struct object_ops timer_ops =
     remove_queue,              /* remove_queue */
     timer_signaled,            /* signaled */
     timer_get_esync_fd,        /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/token.c b/server/token.c
index e40ba10f9aa..056272368a7 100644
--- a/server/token.c
+++ b/server/token.c
@@ -146,6 +146,7 @@ static const struct object_ops token_ops =
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
     NULL,                      /* get_esync_fd */
+    NULL,                      /* get_fsync_idx */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
diff --git a/server/window.c b/server/window.c
index 7e8055bac4a..eaaea11d482 100644
--- a/server/window.c
+++ b/server/window.c
@@ -107,6 +107,7 @@ static const struct object_ops window_ops =
     NULL,                     /* remove_queue */
     NULL,                     /* signaled */
     NULL,                     /* get_esync_fd */
+    NULL,                     /* get_fsync_idx */
     NULL,                     /* satisfied */
     no_signal,                /* signal */
     no_get_fd,                /* get_fd */
diff --git a/server/winstation.c b/server/winstation.c
index 5cd235c528e..75324f8b3a7 100644
--- a/server/winstation.c
+++ b/server/winstation.c
@@ -77,6 +77,7 @@ static const struct object_ops winstation_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
@@ -118,6 +119,7 @@ static const struct object_ops desktop_ops =
     NULL,                         /* remove_queue */
     NULL,                         /* signaled */
     NULL,                         /* get_esync_fd */
+    NULL,                         /* get_fsync_idx */
     NULL,                         /* satisfied */
     no_signal,                    /* signal */
     no_get_fd,                    /* get_fd */
-- 
2.46.0


From 939a6bb2d65067bb71ba620558a2a9a933beba8c Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 16:57:08 -0500
Subject: [PATCH 11/55] server: Add a request to get the shm index associated
 with a waitable handle.

---
 dlls/ntdll/unix/fsync.c |  7 -------
 server/fsync.c          | 28 ++++++++++++++++++++++++++++
 server/object.h         |  2 +-
 server/protocol.def     | 16 ++++++++++++++++
 4 files changed, 45 insertions(+), 8 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index e7a495be365..2f680212fc0 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -95,13 +95,6 @@ int do_fsync(void)
 #endif
 }
 
-enum fsync_type
-{
-    FSYNC_SEMAPHORE = 1,
-    FSYNC_AUTO_EVENT,
-    FSYNC_MANUAL_EVENT,
-};
-
 struct fsync
 {
     enum fsync_type type;
diff --git a/server/fsync.c b/server/fsync.c
index 55a8e709dbf..21f41f54ca1 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -285,3 +285,31 @@ DECL_HANDLER(create_fsync)
 
     if (root) release_object( root );
 }
+
+
+/* Retrieve the index of a shm section which will be signaled by the server. */
+DECL_HANDLER(get_fsync_idx)
+{
+    struct object *obj;
+    enum fsync_type type;
+
+    if (!(obj = get_handle_obj( current->process, req->handle, SYNCHRONIZE, NULL )))
+        return;
+
+    if (obj->ops->get_fsync_idx)
+    {
+        reply->shm_idx = obj->ops->get_fsync_idx( obj, &type );
+        reply->type = type;
+    }
+    else
+    {
+        if (debug_level)
+        {
+            fprintf( stderr, "%04x: fsync: can't wait on object: ", current->id );
+            obj->ops->dump( obj, 0 );
+        }
+        set_error( STATUS_NOT_IMPLEMENTED );
+    }
+
+    release_object( obj );
+}
diff --git a/server/object.h b/server/object.h
index d8f027275db..e224069e69b 100644
--- a/server/object.h
+++ b/server/object.h
@@ -81,7 +81,7 @@ struct object_ops
     /* return the esync fd for this object */
     int (*get_esync_fd)(struct object *, enum esync_type *type);
     /* return the fsync shm idx for this object */
-    unsigned int (*get_fsync_idx)(struct object *);
+    unsigned int (*get_fsync_idx)(struct object *, enum fsync_type *type);
     /* wait satisfied */
     void (*satisfied)(struct object *,struct wait_queue_entry *);
     /* signal an object */
diff --git a/server/protocol.def b/server/protocol.def
index 39b29ed9658..ed08feccc37 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4005,6 +4005,14 @@ enum esync_type
 @REQ(get_esync_apc_fd)
 @END
 
+enum fsync_type
+{
+    FSYNC_SEMAPHORE = 1,
+    FSYNC_AUTO_EVENT,
+    FSYNC_MANUAL_EVENT,
+    FSYNC_MANUAL_SERVER,
+};
+
 /* Create a new futex-based synchronization object */
 @REQ(create_fsync)
     unsigned int access;        /* wanted access rights */
@@ -4015,3 +4023,11 @@ enum esync_type
     obj_handle_t handle;        /* handle to the object */
     unsigned int shm_idx;       /* this object's index into the shm section */
 @END
+
+/* Retrieve the shm index for an object. */
+@REQ(get_fsync_idx)
+    obj_handle_t handle;        /* handle to the object */
+@REPLY
+    int          type;
+    unsigned int shm_idx;
+@END
-- 
2.46.0


From 44c1cd5bcc198a4d07cc61177abefedd16cb2445 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 17:20:36 -0500
Subject: [PATCH 12/55] server: Create futex sections for process objects.

---
 server/fsync.c   | 49 +++++++++++++++++++++++++++++-------------------
 server/fsync.h   |  1 +
 server/process.c | 15 ++++++++++++++-
 server/process.h |  1 +
 4 files changed, 46 insertions(+), 20 deletions(-)

diff --git a/server/fsync.c b/server/fsync.c
index 21f41f54ca1..ae4dc7d7318 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -207,6 +207,35 @@ static void *get_shm( unsigned int idx )
 /* FIXME: This is rather inefficient... */
 static unsigned int shm_idx_counter = 1;
 
+unsigned int fsync_alloc_shm( int low, int high )
+{
+#ifdef __linux__
+    int shm_idx = shm_idx_counter++;
+    int *shm;
+
+    while (shm_idx * 8 >= shm_size)
+    {
+        /* Better expand the shm section. */
+        shm_size += pagesize;
+        if (ftruncate( shm_fd, shm_size ) == -1)
+        {
+            fprintf( stderr, "fsync: couldn't expand %s to size %jd: ",
+                shm_name, shm_size );
+            perror( "ftruncate" );
+        }
+    }
+
+    shm = get_shm( shm_idx );
+    assert(shm);
+    shm[0] = low;
+    shm[1] = high;
+
+    return shm_idx;
+#else
+    return 0;
+#endif
+}
+
 struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
                             unsigned int attr, int low, int high,
                             const struct security_descriptor *sd )
@@ -218,32 +247,14 @@ struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
     {
         if (get_error() != STATUS_OBJECT_NAME_EXISTS)
         {
-            int *shm;
-
             /* initialize it if it didn't already exist */
 
-            fsync->shm_idx = shm_idx_counter++;
-            while (fsync->shm_idx * 8 >= shm_size)
-            {
-                /* Better expand the shm section. */
-                shm_size += pagesize;
-                if (ftruncate( shm_fd, shm_size ) == -1)
-                {
-                    fprintf( stderr, "fsync: couldn't expand %s to size %lld: ",
-                        shm_name, (long long)shm_size );
-                    perror( "ftruncate" );
-                }
-            }
-
             /* Initialize the shared memory portion. We want to do this on the
              * server side to avoid a potential though unlikely race whereby
              * the same object is opened and used between the time it's created
              * and the time its shared memory portion is initialized. */
 
-            shm = get_shm( fsync->shm_idx );
-            assert(shm);
-            shm[0] = low;
-            shm[1] = high;
+            fsync->shm_idx = fsync_alloc_shm( low, high );
         }
     }
 
diff --git a/server/fsync.h b/server/fsync.h
index 0b7e46cdaf3..bbd104f3e16 100644
--- a/server/fsync.h
+++ b/server/fsync.h
@@ -20,3 +20,4 @@
 
 extern int do_fsync(void);
 extern void fsync_init(void);
+extern unsigned int fsync_alloc_shm( int low, int high );
diff --git a/server/process.c b/server/process.c
index ea7da2db209..b8c39f0694f 100644
--- a/server/process.c
+++ b/server/process.c
@@ -64,6 +64,7 @@
 #include "user.h"
 #include "security.h"
 #include "esync.h"
+#include "fsync.h"
 
 /* process object */
 
@@ -97,6 +98,7 @@ static void process_poll_event( struct fd *fd, int event );
 static struct list *process_get_kernel_obj_list( struct object *obj );
 static void process_destroy( struct object *obj );
 static int process_get_esync_fd( struct object *obj, enum esync_type *type );
+static unsigned int process_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
 
 static const struct object_ops process_ops =
@@ -108,7 +110,7 @@ static const struct object_ops process_ops =
     remove_queue,                /* remove_queue */
     process_signaled,            /* signaled */
     process_get_esync_fd,        /* get_esync_fd */
-    NULL,                        /* get_fsync_idx */
+    process_get_fsync_idx,       /* get_fsync_idx */
     no_satisfied,                /* satisfied */
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
@@ -694,6 +696,7 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     memset( &process->image_info, 0, sizeof(process->image_info) );
     list_init( &process->rawinput_entry );
     process->esync_fd        = -1;
+    process->fsync_idx       = 0;
     list_init( &process->kernel_object );
     list_init( &process->thread_list );
     list_init( &process->locks );
@@ -744,6 +747,9 @@ struct process *create_process( int fd, struct process *parent, unsigned int fla
     if (!process->handles || !process->token) goto error;
     process->session_id = token_get_session_id( process->token );
 
+    if (do_fsync())
+        process->fsync_idx = fsync_alloc_shm( 0, 0 );
+
     if (do_esync())
         process->esync_fd = esync_create_fd( 0, 0 );
 
@@ -820,6 +826,13 @@ static int process_get_esync_fd( struct object *obj, enum esync_type *type )
     return process->esync_fd;
 }
 
+static unsigned int process_get_fsync_idx( struct object *obj, enum fsync_type *type )
+{
+    struct process *process = (struct process *)obj;
+    *type = FSYNC_MANUAL_SERVER;
+    return process->fsync_idx;
+}
+
 static unsigned int process_map_access( struct object *obj, unsigned int access )
 {
     access = default_map_access( obj, access );
diff --git a/server/process.h b/server/process.h
index bedd8bb4586..b2aedb69566 100644
--- a/server/process.h
+++ b/server/process.h
@@ -87,6 +87,7 @@ struct process
     struct list          kernel_object;   /* list of kernel object pointers */
     pe_image_info_t      image_info;      /* main exe image info */
     int                  esync_fd;        /* esync file descriptor (signaled on exit) */
+    unsigned int         fsync_idx;
 };
 
 /* process functions */
-- 
2.46.0


From 4eb1fba59f3ce270131cf053acbe842cf7ecce28 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 17:30:47 -0500
Subject: [PATCH 13/55] ntdll, server: Implement waiting on server-bound
 objects.

---
 dlls/ntdll/unix/fsync.c | 51 +++++++++++++++++++++++++++++++++++++++--
 server/fsync.c          | 27 ++++++++++++++++++++++
 server/fsync.h          |  2 ++
 server/thread.c         |  4 ++++
 4 files changed, 82 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2f680212fc0..ec8b3121ed1 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -205,6 +205,49 @@ static struct fsync *get_cached_object( HANDLE handle )
     return &fsync_list[entry][idx];
 }
 
+/* Gets an object. This is either a proper fsync object (i.e. an event,
+ * semaphore, etc. created using create_fsync) or a generic synchronizable
+ * server-side object which the server will signal (e.g. a process, thread,
+ * message queue, etc.) */
+static NTSTATUS get_object( HANDLE handle, struct fsync **obj )
+{
+    NTSTATUS ret = STATUS_SUCCESS;
+    unsigned int shm_idx = 0;
+    enum fsync_type type;
+
+    if ((*obj = get_cached_object( handle ))) return STATUS_SUCCESS;
+
+    if ((INT_PTR)handle < 0)
+    {
+        /* We can deal with pseudo-handles, but it's just easier this way */
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+    /* We need to try grabbing it from the server. */
+    SERVER_START_REQ( get_fsync_idx )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        if (!(ret = wine_server_call( req )))
+        {
+            shm_idx = reply->shm_idx;
+            type    = reply->type;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (ret)
+    {
+        WARN("Failed to retrieve shm index for handle %p, status %#x.\n", handle, (unsigned int)ret);
+        *obj = NULL;
+        return ret;
+    }
+
+    TRACE("Got shm index %d for handle %p.\n", shm_idx, handle);
+
+    *obj = add_to_list( handle, type, get_shm( shm_idx ) );
+    return ret;
+}
+
 NTSTATUS fsync_close( HANDLE handle )
 {
     UINT_PTR entry, idx = handle_to_index( handle, &entry );
@@ -419,10 +462,13 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
 
     for (i = 0; i < count; i++)
     {
-        if ((objs[i] = get_cached_object( handles[i] )))
+        ret = get_object( handles[i], &objs[i] );
+        if (ret == STATUS_SUCCESS)
             has_fsync = 1;
-        else
+        else if (ret == STATUS_NOT_IMPLEMENTED)
             has_server = 1;
+        else
+            return ret;
     }
 
     if (has_fsync && has_server)
@@ -495,6 +541,7 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
                         break;
                     }
                     case FSYNC_MANUAL_EVENT:
+                    case FSYNC_MANUAL_SERVER:
                     {
                         struct event *event = obj->shm;
 
diff --git a/server/fsync.c b/server/fsync.c
index ae4dc7d7318..da30d94f1f7 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -22,6 +22,7 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdio.h>
 #include <stdarg.h>
 #include <sys/mman.h>
@@ -265,6 +266,32 @@ struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
 #endif
 }
 
+static inline int futex_wake( int *addr, int val )
+{
+    return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
+}
+
+/* shm layout for events or event-like objects. */
+struct fsync_event
+{
+    int signaled;
+    int unused;
+};
+
+void fsync_wake_up( struct object *obj )
+{
+    struct fsync_event *event;
+    enum fsync_type type;
+
+    if (obj->ops->get_fsync_idx)
+    {
+        event = get_shm( obj->ops->get_fsync_idx( obj, &type ) );
+
+        if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
+            futex_wake( &event->signaled, INT_MAX );
+    }
+}
+
 DECL_HANDLER(create_fsync)
 {
     struct fsync *fsync;
diff --git a/server/fsync.h b/server/fsync.h
index bbd104f3e16..2ff98cb64cb 100644
--- a/server/fsync.h
+++ b/server/fsync.h
@@ -21,3 +21,5 @@
 extern int do_fsync(void);
 extern void fsync_init(void);
 extern unsigned int fsync_alloc_shm( int low, int high );
+extern void fsync_wake_up( struct object *obj );
+extern void fsync_clear( struct object *obj );
diff --git a/server/thread.c b/server/thread.c
index f652e2d6813..9b5aa3aeaad 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -51,6 +51,7 @@
 #include "user.h"
 #include "security.h"
 #include "esync.h"
+#include "fsync.h"
 
 
 /* thread queues */
@@ -1091,6 +1092,9 @@ void wake_up( struct object *obj, int max )
     struct list *ptr;
     int ret;
 
+    if (do_fsync())
+        fsync_wake_up( obj );
+
     if (do_esync())
         esync_wake_up( obj );
 
-- 
2.46.0


From 4173bfbd586adce7b94cea298f1f72f10109f8a7 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 17:37:55 -0500
Subject: [PATCH 14/55] server: Create futexes for event objects.

---
 server/event.c | 21 ++++++++++++++++++++-
 server/fsync.c | 13 +++++++++++++
 2 files changed, 33 insertions(+), 1 deletion(-)

diff --git a/server/event.c b/server/event.c
index f5a25c02293..9acd7fa263c 100644
--- a/server/event.c
+++ b/server/event.c
@@ -36,6 +36,7 @@
 #include "request.h"
 #include "security.h"
 #include "esync.h"
+#include "fsync.h"
 
 static const WCHAR event_name[] = {'E','v','e','n','t'};
 
@@ -58,12 +59,14 @@ struct event
     int            manual_reset;    /* is it a manual reset event? */
     int            signaled;        /* event has been signaled */
     int            esync_fd;        /* esync file descriptor */
+    unsigned int   fsync_idx;
 };
 
 static void event_dump( struct object *obj, int verbose );
 static int event_signaled( struct object *obj, struct wait_queue_entry *entry );
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static int event_get_esync_fd( struct object *obj, enum esync_type *type );
+static unsigned int event_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static int event_signal( struct object *obj, unsigned int access);
 static struct list *event_get_kernel_obj_list( struct object *obj );
 static void event_destroy( struct object *obj );
@@ -77,7 +80,7 @@ static const struct object_ops event_ops =
     remove_queue,              /* remove_queue */
     event_signaled,            /* signaled */
     event_get_esync_fd,        /* get_esync_fd */
-    NULL,                      /* get_fsync_idx */
+    event_get_fsync_idx,       /* get_fsync_idx */
     event_satisfied,           /* satisfied */
     event_signal,              /* signal */
     no_get_fd,                 /* get_fd */
@@ -159,6 +162,9 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
             event->manual_reset = manual_reset;
             event->signaled     = initial_state;
 
+            if (do_fsync())
+                event->fsync_idx = fsync_alloc_shm( initial_state, 0 );
+
             if (do_esync())
                 event->esync_fd = esync_create_fd( initial_state, 0 );
         }
@@ -181,6 +187,9 @@ static void pulse_event( struct event *event )
     /* wake up all waiters if manual reset, a single one otherwise */
     wake_up( &event->obj, !event->manual_reset );
     event->signaled = 0;
+
+    if (do_fsync())
+        fsync_clear( &event->obj );
 }
 
 void set_event( struct event *event )
@@ -205,6 +214,9 @@ void reset_event( struct event *event )
     }
     event->signaled = 0;
 
+    if (do_fsync())
+        fsync_clear( &event->obj );
+
     if (do_esync())
         esync_clear( event->esync_fd );
 }
@@ -231,6 +243,13 @@ static int event_get_esync_fd( struct object *obj, enum esync_type *type )
     return event->esync_fd;
 }
 
+static unsigned int event_get_fsync_idx( struct object *obj, enum fsync_type *type )
+{
+    struct event *event = (struct event *)obj;
+    *type = FSYNC_MANUAL_SERVER;
+    return event->fsync_idx;
+}
+
 static void event_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct event *event = (struct event *)obj;
diff --git a/server/fsync.c b/server/fsync.c
index da30d94f1f7..07c0367d02c 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -292,6 +292,19 @@ void fsync_wake_up( struct object *obj )
     }
 }
 
+void fsync_clear( struct object *obj )
+{
+    struct fsync_event *event;
+    enum fsync_type type;
+
+    if (obj->ops->get_fsync_idx)
+    {
+        event = get_shm( obj->ops->get_fsync_idx( obj, &type ) );
+
+        __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
+    }
+}
+
 DECL_HANDLER(create_fsync)
 {
     struct fsync *fsync;
-- 
2.46.0


From 00592d02a7fb12fb5975bd78627783e13d0a4a5d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 17:44:18 -0500
Subject: [PATCH 15/55] server: Allow (re)setting fsync events on the server
 side.

---
 server/event.c | 16 ++++++++++++++++
 server/fsync.c | 19 ++++++++++++++++++-
 server/fsync.h |  6 ++++++
 3 files changed, 40 insertions(+), 1 deletion(-)

diff --git a/server/event.c b/server/event.c
index 9acd7fa263c..aa1b0a4002a 100644
--- a/server/event.c
+++ b/server/event.c
@@ -175,6 +175,10 @@ struct event *create_event( struct object *root, const struct unicode_str *name,
 struct event *get_event_obj( struct process *process, obj_handle_t handle, unsigned int access )
 {
     struct object *obj;
+
+    if (do_fsync() && (obj = get_handle_obj( process, handle, access, &fsync_ops)))
+        return (struct event *)obj; /* even though it's not an event */
+
     if (do_esync() && (obj = get_handle_obj( process, handle, access, &esync_ops)))
         return (struct event *)obj; /* even though it's not an event */
 
@@ -194,6 +198,12 @@ static void pulse_event( struct event *event )
 
 void set_event( struct event *event )
 {
+    if (do_fsync() && event->obj.ops == &fsync_ops)
+    {
+        fsync_set_event( (struct fsync *)event );
+        return;
+    }
+
     if (do_esync() && event->obj.ops == &esync_ops)
     {
         esync_set_event( (struct esync *)event );
@@ -207,6 +217,12 @@ void set_event( struct event *event )
 
 void reset_event( struct event *event )
 {
+    if (do_fsync() && event->obj.ops == &fsync_ops)
+    {
+        fsync_reset_event( (struct fsync *)event );
+        return;
+    }
+
     if (do_esync() && event->obj.ops == &esync_ops)
     {
         esync_reset_event( (struct esync *)event );
diff --git a/server/fsync.c b/server/fsync.c
index 07c0367d02c..1d6a49fb517 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -132,7 +132,7 @@ struct fsync
 static void fsync_dump( struct object *obj, int verbose );
 static void fsync_destroy( struct object *obj );
 
-static const struct object_ops fsync_ops =
+const struct object_ops fsync_ops =
 {
     sizeof(struct fsync),      /* size */
     &no_type,                  /* type */
@@ -305,6 +305,23 @@ void fsync_clear( struct object *obj )
     }
 }
 
+void fsync_set_event( struct fsync *fsync )
+{
+    struct fsync_event *event = get_shm( fsync->shm_idx );
+    assert( fsync->obj.ops == &fsync_ops );
+
+    if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
+        futex_wake( &event->signaled, INT_MAX );
+}
+
+void fsync_reset_event( struct fsync *fsync )
+{
+    struct fsync_event *event = get_shm( fsync->shm_idx );
+    assert( fsync->obj.ops == &fsync_ops );
+
+    __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
+}
+
 DECL_HANDLER(create_fsync)
 {
     struct fsync *fsync;
diff --git a/server/fsync.h b/server/fsync.h
index 2ff98cb64cb..087d482717b 100644
--- a/server/fsync.h
+++ b/server/fsync.h
@@ -23,3 +23,9 @@ extern void fsync_init(void);
 extern unsigned int fsync_alloc_shm( int low, int high );
 extern void fsync_wake_up( struct object *obj );
 extern void fsync_clear( struct object *obj );
+
+struct fsync;
+
+extern const struct object_ops fsync_ops;
+extern void fsync_set_event( struct fsync *fsync );
+extern void fsync_reset_event( struct fsync *fsync );
-- 
2.46.0


From e8e924ad6fbae9f44cc64853d13fc8f4d35c8e7e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 17:47:50 -0500
Subject: [PATCH 16/55] server: Create futexes for thread objects.

---
 server/thread.c | 14 +++++++++++++-
 server/thread.h |  1 +
 2 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/server/thread.c b/server/thread.c
index 9b5aa3aeaad..2985d212cde 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -181,6 +181,7 @@ struct type_descr thread_type =
 static void dump_thread( struct object *obj, int verbose );
 static int thread_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int thread_get_esync_fd( struct object *obj, enum esync_type *type );
+static unsigned int thread_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static unsigned int thread_map_access( struct object *obj, unsigned int access );
 static void thread_poll_event( struct fd *fd, int event );
 static struct list *thread_get_kernel_obj_list( struct object *obj );
@@ -195,7 +196,7 @@ static const struct object_ops thread_ops =
     remove_queue,               /* remove_queue */
     thread_signaled,            /* signaled */
     thread_get_esync_fd,        /* get_esync_fd */
-    NULL,                       /* get_fsync_idx */
+    thread_get_fsync_idx,       /* get_fsync_idx */
     no_satisfied,               /* satisfied */
     no_signal,                  /* signal */
     no_get_fd,                  /* get_fd */
@@ -237,6 +238,7 @@ static inline void init_thread_structure( struct thread *thread )
     thread->entry_point     = 0;
     thread->esync_fd        = -1;
     thread->esync_apc_fd    = -1;
+    thread->fsync_idx       = 0;
     thread->system_regs     = 0;
     thread->queue           = NULL;
     thread->wait            = NULL;
@@ -384,6 +386,9 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
         }
     }
 
+    if (do_fsync())
+        thread->fsync_idx = fsync_alloc_shm( 0, 0 );
+
     if (do_esync())
     {
         thread->esync_fd = esync_create_fd( 0, 0 );
@@ -497,6 +502,13 @@ static int thread_get_esync_fd( struct object *obj, enum esync_type *type )
     return thread->esync_fd;
 }
 
+static unsigned int thread_get_fsync_idx( struct object *obj, enum fsync_type *type )
+{
+    struct thread *thread = (struct thread *)obj;
+    *type = FSYNC_MANUAL_SERVER;
+    return thread->fsync_idx;
+}
+
 static unsigned int thread_map_access( struct object *obj, unsigned int access )
 {
     access = default_map_access( obj, access );
diff --git a/server/thread.h b/server/thread.h
index b9f2a3f1cf0..8ca234fc65a 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -57,6 +57,7 @@ struct thread
     struct list            mutex_list;    /* list of currently owned mutexes */
     int                    esync_fd;      /* esync file descriptor (signalled on exit) */
     int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
+    unsigned int           fsync_idx;
     unsigned int           system_regs;   /* which system regs have been set */
     struct msg_queue      *queue;         /* message queue */
     struct thread_wait    *wait;          /* current wait condition if sleeping */
-- 
2.46.0


From 630d668e329342c09db86cfce28c7a92f745142b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 17:53:59 -0500
Subject: [PATCH 17/55] server: Create futexes for message queues.

Rebased by Alexis Peypelut
---
 server/protocol.def |  1 +
 server/queue.c      | 34 ++++++++++++++++++++++++++++++----
 2 files changed, 31 insertions(+), 4 deletions(-)

diff --git a/server/protocol.def b/server/protocol.def
index ed08feccc37..7ebd1b0a3b7 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4011,6 +4011,7 @@ enum fsync_type
     FSYNC_AUTO_EVENT,
     FSYNC_MANUAL_EVENT,
     FSYNC_MANUAL_SERVER,
+    FSYNC_QUEUE,
 };
 
 /* Create a new futex-based synchronization object */
diff --git a/server/queue.c b/server/queue.c
index 64b77f331fa..67ed46844ee 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -45,6 +45,7 @@
 #include "request.h"
 #include "user.h"
 #include "esync.h"
+#include "fsync.h"
 
 #define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
 #define WM_NCMOUSELAST  (WM_NCMOUSEFIRST+(WM_MOUSELAST-WM_MOUSEFIRST))
@@ -136,6 +137,7 @@ struct msg_queue
     const queue_shm_t     *shared;          /* queue in session shared memory */
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
+    unsigned int           fsync_idx;
 };
 
 struct hotkey
@@ -153,6 +155,7 @@ static int msg_queue_add_queue( struct object *obj, struct wait_queue_entry *ent
 static void msg_queue_remove_queue( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type );
+static unsigned int msg_queue_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void msg_queue_destroy( struct object *obj );
 static void msg_queue_poll_event( struct fd *fd, int event );
@@ -169,7 +172,7 @@ static const struct object_ops msg_queue_ops =
     msg_queue_remove_queue,    /* remove_queue */
     msg_queue_signaled,        /* signaled */
     msg_queue_get_esync_fd,    /* get_esync_fd */
-    NULL,                      /* get_fsync_idx */
+    msg_queue_get_fsync_idx,   /* get_fsync_idx */
     msg_queue_satisfied,       /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -322,12 +325,19 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->keystate_lock   = 0;
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
+        queue->fsync_idx       = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
         list_init( &queue->expired_timers );
         for (i = 0; i < NB_MSG_KINDS; i++) list_init( &queue->msg_list[i] );
 
+        if (do_fsync())
+            queue->fsync_idx = fsync_alloc_shm( 0, 0 );
+
+        if (do_esync())
+            queue->esync_fd = esync_create_fd( 0, 0 );
+
         if (!(queue->shared = alloc_shared_object()))
         {
             release_object( queue );
@@ -344,9 +354,6 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         }
         SHARED_WRITE_END;
 
-        if (do_esync())
-            queue->esync_fd = esync_create_fd( 0, 0 );
-
         thread->queue = queue;
 
         if ((desktop = get_thread_desktop( thread, 0 )))
@@ -754,6 +761,9 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
         queue->keystate_lock = 0;
     }
 
+    if (do_fsync() && !is_signaled( queue ))
+        fsync_clear( &queue->obj );
+
     if (do_esync() && !is_signaled( queue ))
         esync_clear( queue->esync_fd );
 }
@@ -1300,6 +1310,13 @@ static int msg_queue_get_esync_fd( struct object *obj, enum esync_type *type )
     return queue->esync_fd;
 }
 
+static unsigned int msg_queue_get_fsync_idx( struct object *obj, enum fsync_type *type )
+{
+    struct msg_queue *queue = (struct msg_queue *)obj;
+    *type = FSYNC_QUEUE;
+    return queue->fsync_idx;
+}
+
 static void msg_queue_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct msg_queue *queue = (struct msg_queue *)obj;
@@ -3135,6 +3152,9 @@ DECL_HANDLER(set_queue_mask)
             else wake_up( &queue->obj, 0 );
         }
 
+        if (do_fsync() && !is_signaled( queue ))
+            fsync_clear( &queue->obj );
+
         if (do_esync() && !is_signaled( queue ))
             esync_clear( queue->esync_fd );
     }
@@ -3158,6 +3178,9 @@ DECL_HANDLER(get_queue_status)
         }
         SHARED_WRITE_END;
 
+        if (do_fsync() && !is_signaled( queue ))
+            fsync_clear( &queue->obj );
+
         if (do_esync() && !is_signaled( queue ))
             esync_clear( queue->esync_fd );
     }
@@ -3418,6 +3441,9 @@ DECL_HANDLER(get_message)
 
     set_error( STATUS_PENDING );  /* FIXME */
 
+    if (do_fsync() && !is_signaled( queue ))
+        fsync_clear( &queue->obj );
+
     if (do_esync() && !is_signaled( queue ))
         esync_clear( queue->esync_fd );
 }
-- 
2.46.0


From b39b8b58a6bd6eef3b1f5801db5002e863f4854e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 19:24:15 -0500
Subject: [PATCH 18/55] server, ntdll: Implement message waits.

The approach of giving the queue fd to ntdll to wait on doesn't work here.
Fortunately, the way esync has ended up lends itself very easily to a rather
clean approach: let the server do it the normal way.

Rebased by Alexis Peypelut
---
 dlls/ntdll/unix/fsync.c | 52 ++++++++++++++++++++++++++++++++++++++++-
 server/protocol.def     |  4 ++++
 server/queue.c          | 22 +++++++++++++++++
 3 files changed, 77 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index ec8b3121ed1..edad675fa7a 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -437,12 +437,13 @@ static LONGLONG update_timeout( ULONGLONG end )
     return timeleft;
 }
 
-NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
+static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
     struct futex_wait_block futexes[MAXIMUM_WAIT_OBJECTS];
     struct fsync *objs[MAXIMUM_WAIT_OBJECTS];
     int has_fsync = 0, has_server = 0;
+    BOOL msgwait = FALSE;
     int dummy_futex = 0;
     LONGLONG timeleft;
     LARGE_INTEGER now;
@@ -471,6 +472,9 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
             return ret;
     }
 
+    if (objs[count - 1] && objs[count - 1]->type == FSYNC_QUEUE)
+        msgwait = TRUE;
+
     if (has_fsync && has_server)
         FIXME("Can't wait on fsync and server objects at the same time!\n");
     else if (has_server)
@@ -482,6 +486,9 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
         for (i = 0; i < count; i++)
             TRACE(" %p", handles[i]);
 
+        if (msgwait)
+            TRACE(" or driver events");
+
         if (!timeout)
             TRACE(", timeout = INFINITE.\n");
         else
@@ -542,6 +549,7 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
                     }
                     case FSYNC_MANUAL_EVENT:
                     case FSYNC_MANUAL_SERVER:
+                    case FSYNC_QUEUE:
                     {
                         struct event *event = obj->shm;
 
@@ -602,3 +610,45 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles,
         return STATUS_NOT_IMPLEMENTED;
     }
 }
+
+/* Like esync, we need to let the server know when we are doing a message wait,
+ * and when we are done with one, so that all of the code surrounding hung
+ * queues works, and we also need this for WaitForInputIdle().
+ *
+ * Unlike esync, we can't wait on the queue fd itself locally. Instead we let
+ * the server do that for us, the way it normally does. This could actually
+ * work for esync too, and that might be better. */
+static void server_set_msgwait( int in_msgwait )
+{
+    SERVER_START_REQ( fsync_msgwait )
+    {
+        req->in_msgwait = in_msgwait;
+        wine_server_call( req );
+    }
+    SERVER_END_REQ;
+}
+
+/* This is a very thin wrapper around the proper implementation above. The
+ * purpose is to make sure the server knows when we are doing a message wait.
+ * This is separated into a wrapper function since there are at least a dozen
+ * exit paths from fsync_wait_objects(). */
+NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
+                             BOOLEAN alertable, const LARGE_INTEGER *timeout )
+{
+    BOOL msgwait = FALSE;
+    struct fsync *obj;
+    NTSTATUS ret;
+
+    if (!get_object( handles[count - 1], &obj ) && obj->type == FSYNC_QUEUE)
+    {
+        msgwait = TRUE;
+        server_set_msgwait( 1 );
+    }
+
+    ret = __fsync_wait_objects( count, handles, wait_any, alertable, timeout );
+
+    if (msgwait)
+        server_set_msgwait( 0 );
+
+    return ret;
+}
diff --git a/server/protocol.def b/server/protocol.def
index 7ebd1b0a3b7..58fe7bd47a7 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4032,3 +4032,7 @@ enum fsync_type
     int          type;
     unsigned int shm_idx;
 @END
+
+@REQ(fsync_msgwait)
+    int          in_msgwait;    /* are we in a message wait? */
+@END
diff --git a/server/queue.c b/server/queue.c
index 67ed46844ee..e4744d997c0 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -138,6 +138,7 @@ struct msg_queue
     int                    esync_fd;        /* esync file descriptor (signalled on message) */
     int                    esync_in_msgwait; /* our thread is currently waiting on us */
     unsigned int           fsync_idx;
+    int                    fsync_in_msgwait; /* our thread is currently waiting on us */
 };
 
 struct hotkey
@@ -326,6 +327,7 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->esync_fd        = -1;
         queue->esync_in_msgwait = 0;
         queue->fsync_idx       = 0;
+        queue->fsync_in_msgwait = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -1246,6 +1248,9 @@ static int is_queue_hung( struct msg_queue *queue )
             return 0;  /* thread is waiting on queue -> not hung */
     }
 
+    if (do_fsync() && queue->fsync_in_msgwait)
+        return 0;   /* thread is waiting on queue in absentia -> not hung */
+
     if (do_esync() && queue->esync_in_msgwait)
         return 0;   /* thread is waiting on queue in absentia -> not hung */
 
@@ -4235,6 +4240,23 @@ DECL_HANDLER(esync_msgwait)
         set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
 }
 
+DECL_HANDLER(fsync_msgwait)
+{
+    struct msg_queue *queue = get_current_queue();
+    const queue_shm_t *queue_shm;
+
+    if (!queue) return;
+    queue_shm = queue->shared;
+    queue->fsync_in_msgwait = req->in_msgwait;
+
+    if (current->process->idle_event && !(queue_shm->wake_mask & QS_SMRESULT))
+        set_event( current->process->idle_event );
+
+    /* and start/stop waiting on the driver */
+    if (queue->fd)
+        set_fd_events( queue->fd, req->in_msgwait ? POLLIN : 0 );
+}
+
 DECL_HANDLER(set_keyboard_repeat)
 {
     struct desktop *desktop;
-- 
2.46.0


From c1f8fd352fc781933a44560b7b1bd51ac811ff18 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 19:36:23 -0500
Subject: [PATCH 19/55] ntdll: Implement NtCreateMutant().

---
 dlls/ntdll/unix/fsync.c | 17 +++++++++++++++++
 dlls/ntdll/unix/fsync.h |  2 ++
 dlls/ntdll/unix/sync.c  |  3 +++
 server/protocol.def     |  1 +
 4 files changed, 23 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index edad675fa7a..9d4d61ad389 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -115,6 +115,13 @@ struct event
 };
 C_ASSERT(sizeof(struct event) == 8);
 
+struct mutex
+{
+    int tid;
+    int count;  /* recursion count */
+};
+C_ASSERT(sizeof(struct mutex) == 8);
+
 static char shm_name[29];
 static int shm_fd;
 static void **shm_addrs;
@@ -426,6 +433,16 @@ NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
+{
+    TRACE("name %s, initial %d.\n",
+        attr ? debugstr_us(attr->ObjectName) : "<no name>", initial);
+
+    return create_fsync( FSYNC_MUTEX, handle, access, attr,
+        initial ? GetCurrentThreadId() : 0, initial ? 1 : 0 );
+}
+
 static LONGLONG update_timeout( ULONGLONG end )
 {
     LARGE_INTEGER now;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 56afeb1f9e8..e7cc1e87b4e 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -29,6 +29,8 @@ extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
 extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
+extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 1404a28f395..205a6d73671 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -635,6 +635,9 @@ NTSTATUS WINAPI NtCreateMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT
 
     *handle = 0;
 
+    if (do_fsync())
+        return fsync_create_mutex( handle, access, attr, owned );
+
     if (do_esync())
         return esync_create_mutex( handle, access, attr, owned );
 
diff --git a/server/protocol.def b/server/protocol.def
index 58fe7bd47a7..e5a0b6e2356 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4010,6 +4010,7 @@ enum fsync_type
     FSYNC_SEMAPHORE = 1,
     FSYNC_AUTO_EVENT,
     FSYNC_MANUAL_EVENT,
+    FSYNC_MUTEX,
     FSYNC_MANUAL_SERVER,
     FSYNC_QUEUE,
 };
-- 
2.46.0


From 76cec55e065aa746511b9f16db145d1772402a87 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 19:42:17 -0500
Subject: [PATCH 20/55] ntdll: Implement NtReleaseMutant().

---
 dlls/ntdll/unix/fsync.c | 23 +++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 27 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 9d4d61ad389..22b67e5d4a4 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -443,6 +443,29 @@ NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
         initial ? GetCurrentThreadId() : 0, initial ? 1 : 0 );
 }
 
+NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev )
+{
+    struct mutex *mutex;
+    struct fsync *obj;
+
+    TRACE("%p, %p.\n", handle, prev);
+
+    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    mutex = obj->shm;
+
+    if (mutex->tid != GetCurrentThreadId()) return STATUS_MUTANT_NOT_OWNED;
+
+    if (prev) *prev = mutex->count;
+
+    if (!--mutex->count)
+    {
+        __atomic_store_n( &mutex->tid, 0, __ATOMIC_SEQ_CST );
+        futex_wake( &mutex->tid, 1 );
+    }
+
+    return STATUS_SUCCESS;
+}
+
 static LONGLONG update_timeout( ULONGLONG end )
 {
     LARGE_INTEGER now;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index e7cc1e87b4e..1867ba88112 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -31,6 +31,7 @@ extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
+extern NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 205a6d73671..c25f17496a6 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -693,6 +693,9 @@ NTSTATUS WINAPI NtReleaseMutant( HANDLE handle, LONG *prev_count )
 {
     unsigned int ret;
 
+    if (do_fsync())
+        return fsync_release_mutex( handle, prev_count );
+
     if (do_esync())
         return esync_release_mutex( handle, prev_count );
 
-- 
2.46.0


From f373dafd3786970d11e326cd4867559f1025e304 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 19:46:17 -0500
Subject: [PATCH 21/55] ntdll: Implement waiting on mutexes.

---
 dlls/ntdll/unix/fsync.c | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 22b67e5d4a4..f4d3c8953cf 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -573,6 +573,28 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         futexes[i].val = current;
                         break;
                     }
+                    case FSYNC_MUTEX:
+                    {
+                        struct mutex *mutex = obj->shm;
+
+                        if (mutex->tid == GetCurrentThreadId())
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            mutex->count++;
+                            return i;
+                        }
+
+                        if (!__sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() ))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            mutex->count = 1;
+                            return i;
+                        }
+
+                        futexes[i].addr = &mutex->tid;
+                        futexes[i].val  = mutex->tid;
+                        break;
+                    }
                     case FSYNC_AUTO_EVENT:
                     {
                         struct event *event = obj->shm;
-- 
2.46.0


From 46c93f05951f81c86c987e19f30c62497b0f9d5d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sat, 1 Sep 2018 20:35:44 -0500
Subject: [PATCH 22/55] ntdll: Implement wait-all.

---
 dlls/ntdll/unix/fsync.c | 204 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 201 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index f4d3c8953cf..0c382de40ae 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -74,6 +74,11 @@ static inline int futex_wake( int *addr, int val )
     return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
 }
 
+static inline int futex_wait( int *addr, int val, struct timespec *timeout )
+{
+    return syscall( __NR_futex, addr, 0, val, timeout, 0, 0 );
+}
+
 int do_fsync(void)
 {
 #ifdef __linux__
@@ -477,6 +482,29 @@ static LONGLONG update_timeout( ULONGLONG end )
     return timeleft;
 }
 
+static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end )
+{
+    int ret;
+
+    if (end)
+    {
+        LONGLONG timeleft = update_timeout( *end );
+        struct timespec tmo_p;
+        tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+        tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+        ret = futex_wait( addr, val, &tmo_p );
+    }
+    else
+        ret = futex_wait( addr, val, NULL );
+
+    if (!ret)
+        return 0;
+    else if (ret < 0 && errno == ETIMEDOUT)
+        return STATUS_TIMEOUT;
+    else
+        return STATUS_PENDING;
+}
+
 static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
@@ -668,9 +696,179 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     }
     else
     {
-        FIXME("Wait-all not implemented.\n");
-        return STATUS_NOT_IMPLEMENTED;
-    }
+        /* Wait-all is a little trickier to implement correctly. Fortunately,
+         * it's not as common.
+         *
+         * The idea is basically just to wait in sequence on every object in the
+         * set. Then when we're done, try to grab them all in a tight loop. If
+         * that fails, release any resources we've grabbed (and yes, we can
+         * reliably do thisit's just mutexes and semaphores that we have to
+         * put back, and in both cases we just put back 1), and if any of that
+         * fails we start over.
+         *
+         * What makes this inherently bad is that we might temporarily grab a
+         * resource incorrectly. Hopefully it'll be quick (and hey, it won't
+         * block on wineserver) so nobody will notice. Besides, consider: if
+         * object A becomes signaled but someone grabs it before we can grab it
+         * and everything else, then they could just as well have grabbed it
+         * before it became signaled. Similarly if object A was signaled and we
+         * were blocking on object B, then B becomes available and someone grabs
+         * A before we can, then they might have grabbed A before B became
+         * signaled. In either case anyone who tries to wait on A or B will be
+         * waiting for an instant while we put things back. */
+
+        NTSTATUS status = STATUS_SUCCESS;
+        int current;
+
+        while (1)
+        {
+tryagain:
+            /* First step: try to wait on each object in sequence. */
+
+            for (i = 0; i < count; i++)
+            {
+                struct fsync *obj = objs[i];
+
+                if (obj && obj->type == FSYNC_MUTEX)
+                {
+                    struct mutex *mutex = obj->shm;
+
+                    if (mutex->tid == GetCurrentThreadId())
+                        continue;
+
+                    while ((current = __atomic_load_n( &mutex->tid, __ATOMIC_SEQ_CST )))
+                    {
+                        status = do_single_wait( &mutex->tid, current, timeout ? &end : NULL );
+                        if (status != STATUS_PENDING)
+                            break;
+                    }
+                }
+                else if (obj)
+                {
+                    /* this works for semaphores too */
+                    struct event *event = obj->shm;
+
+                    while (!__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                    {
+                        status = do_single_wait( &event->signaled, 0, timeout ? &end : NULL );
+                        if (status != STATUS_PENDING)
+                            break;
+                    }
+                }
+
+                if (status == STATUS_TIMEOUT)
+                {
+                    TRACE("Wait timed out.\n");
+                    return status;
+                }
+            }
+
+            /* If we got here and we haven't timed out, that means all of the
+             * handles were signaled. Check to make sure they still are. */
+            for (i = 0; i < count; i++)
+            {
+                struct fsync *obj = objs[i];
+
+                if (obj && obj->type == FSYNC_MUTEX)
+                {
+                    struct mutex *mutex = obj->shm;
+
+                    if (mutex->tid == GetCurrentThreadId())
+                        continue;   /* ok */
+
+                    if (__atomic_load_n( &mutex->tid, __ATOMIC_SEQ_CST ))
+                        goto tryagain;
+                }
+                else if (obj)
+                {
+                    struct event *event = obj->shm;
+
+                    if (!__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                        goto tryagain;
+                }
+            }
+
+            /* Yep, still signaled. Now quick, grab everything. */
+            for (i = 0; i < count; i++)
+            {
+                struct fsync *obj = objs[i];
+                switch (obj->type)
+                {
+                case FSYNC_MUTEX:
+                {
+                    struct mutex *mutex = obj->shm;
+                    if (mutex->tid == GetCurrentThreadId())
+                        break;
+                    if (__sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() ))
+                        goto tooslow;
+                    break;
+                }
+                case FSYNC_SEMAPHORE:
+                {
+                    struct semaphore *semaphore = obj->shm;
+                    if (__sync_fetch_and_sub( &semaphore->count, 1 ) <= 0)
+                        goto tooslow;
+                    break;
+                }
+                case FSYNC_AUTO_EVENT:
+                {
+                    struct event *event = obj->shm;
+                    if (!__sync_val_compare_and_swap( &event->signaled, 1, 0 ))
+                        goto tooslow;
+                    break;
+                }
+                default:
+                    /* If a manual-reset event changed between there and
+                     * here, it's shouldn't be a problem. */
+                    break;
+                }
+            }
+
+            /* If we got here, we successfully waited on every object.
+             * Make sure to let ourselves know that we grabbed the mutexes. */
+            for (i = 0; i < count; i++)
+            {
+                if (objs[i] && objs[i]->type == FSYNC_MUTEX)
+                {
+                    struct mutex *mutex = objs[i]->shm;
+                    mutex->count++;
+                }
+            }
+
+            TRACE("Wait successful.\n");
+            return STATUS_SUCCESS;
+
+tooslow:
+            for (--i; i >= 0; i--)
+            {
+                struct fsync *obj = objs[i];
+                switch (obj->type)
+                {
+                case FSYNC_MUTEX:
+                {
+                    struct mutex *mutex = obj->shm;
+                    __atomic_store_n( &mutex->tid, 0, __ATOMIC_SEQ_CST );
+                    break;
+                }
+                case FSYNC_SEMAPHORE:
+                {
+                    struct semaphore *semaphore = obj->shm;
+                    __sync_fetch_and_add( &semaphore->count, 1 );
+                    break;
+                }
+                case FSYNC_AUTO_EVENT:
+                {
+                    struct event *event = obj->shm;
+                    __atomic_store_n( &event->signaled, 1, __ATOMIC_SEQ_CST );
+                    break;
+                }
+                default:
+                    /* doesn't need to be put back */
+                    break;
+                }
+            }
+        } /* while (1) */
+    } /* else (wait-all) */
 }
 
 /* Like esync, we need to let the server know when we are doing a message wait,
-- 
2.46.0


From a4d0d5841ea0f6a32a57a1602795415d45333e5f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 11:41:07 -0500
Subject: [PATCH 23/55] ntdll: Implement NtSignalAndWaitForSingleObject().

---
 dlls/ntdll/unix/fsync.c | 28 ++++++++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  2 ++
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 33 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 0c382de40ae..b5116e07920 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -912,3 +912,31 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 
     return ret;
 }
+
+NTSTATUS fsync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
+    const LARGE_INTEGER *timeout )
+{
+    struct fsync *obj = get_cached_object( signal );
+    NTSTATUS ret;
+
+    if (!obj) return STATUS_INVALID_HANDLE;
+
+    switch (obj->type)
+    {
+    case FSYNC_SEMAPHORE:
+        ret = fsync_release_semaphore( signal, 1, NULL );
+        break;
+    case FSYNC_AUTO_EVENT:
+    case FSYNC_MANUAL_EVENT:
+        ret = fsync_set_event( signal, NULL );
+        break;
+    case FSYNC_MUTEX:
+        ret = fsync_release_mutex( signal, NULL );
+        break;
+    default:
+        return STATUS_OBJECT_TYPE_MISMATCH;
+    }
+    if (ret) return ret;
+
+    return fsync_wait_objects( 1, &wait, TRUE, alertable, timeout );
+}
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 1867ba88112..c39c3a14e59 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -35,3 +35,5 @@ extern NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
+extern NTSTATUS fsync_signal_and_wait( HANDLE signal, HANDLE wait,
+    BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index c25f17496a6..f476963f74f 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1691,6 +1691,9 @@ NTSTATUS WINAPI NtSignalAndWaitForSingleObject( HANDLE signal, HANDLE wait,
     select_op_t select_op;
     UINT flags = SELECT_INTERRUPTIBLE;
 
+    if (do_fsync())
+        return fsync_signal_and_wait( signal, wait, alertable, timeout );
+
     if (do_esync())
         return esync_signal_and_wait( signal, wait, alertable, timeout );
 
-- 
2.46.0


From 7049e3034af23c38a4e67a273fff8e2f8b19473d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 11:48:26 -0500
Subject: [PATCH 24/55] server, ntdll: Also store the fsync type in the server.

---
 dlls/ntdll/unix/fsync.c |  2 ++
 server/fsync.c          | 26 +++++++++++++++++++++++---
 server/protocol.def     |  2 ++
 3 files changed, 27 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index b5116e07920..e65abc525ed 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -290,12 +290,14 @@ static NTSTATUS create_fsync( enum fsync_type type, HANDLE *handle,
         req->access = access;
         req->low    = low;
         req->high   = high;
+        req->type   = type;
         wine_server_add_data( req, objattr, len );
         ret = wine_server_call( req );
         if (!ret || ret == STATUS_OBJECT_NAME_EXISTS)
         {
             *handle = wine_server_ptr_handle( reply->handle );
             shm_idx = reply->shm_idx;
+            type    = reply->type;
         }
     }
     SERVER_END_REQ;
diff --git a/server/fsync.c b/server/fsync.c
index 1d6a49fb517..d32d5f9c689 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -127,6 +127,7 @@ struct fsync
 {
     struct object  obj;
     unsigned int   shm_idx;
+    enum fsync_type type;
 };
 
 static void fsync_dump( struct object *obj, int verbose );
@@ -237,9 +238,16 @@ unsigned int fsync_alloc_shm( int low, int high )
 #endif
 }
 
+static int type_matches( enum fsync_type type1, enum fsync_type type2 )
+{
+    return (type1 == type2) ||
+           ((type1 == FSYNC_AUTO_EVENT || type1 == FSYNC_MANUAL_EVENT) &&
+            (type2 == FSYNC_AUTO_EVENT || type2 == FSYNC_MANUAL_EVENT));
+}
+
 struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
-                            unsigned int attr, int low, int high,
-                            const struct security_descriptor *sd )
+    unsigned int attr, int low, int high, enum fsync_type type,
+    const struct security_descriptor *sd )
 {
 #ifdef __linux__
     struct fsync *fsync;
@@ -256,6 +264,17 @@ struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
              * and the time its shared memory portion is initialized. */
 
             fsync->shm_idx = fsync_alloc_shm( low, high );
+            fsync->type = type;
+        }
+        else
+        {
+            /* validate the type */
+            if (!type_matches( type, fsync->type ))
+            {
+                release_object( &fsync->obj );
+                set_error( STATUS_OBJECT_TYPE_MISMATCH );
+                return NULL;
+            }
         }
     }
 
@@ -339,7 +358,7 @@ DECL_HANDLER(create_fsync)
     if (!objattr) return;
 
     if ((fsync = create_fsync( root, &name, objattr->attributes, req->low,
-                               req->high, sd )))
+                               req->high, req->type, sd )))
     {
         if (get_error() == STATUS_OBJECT_NAME_EXISTS)
             reply->handle = alloc_handle( current->process, fsync, req->access, objattr->attributes );
@@ -348,6 +367,7 @@ DECL_HANDLER(create_fsync)
                                                           req->access, objattr->attributes );
 
         reply->shm_idx = fsync->shm_idx;
+        reply->type = fsync->type;
         release_object( fsync );
     }
 
diff --git a/server/protocol.def b/server/protocol.def
index e5a0b6e2356..1bf698541dd 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4020,9 +4020,11 @@ enum fsync_type
     unsigned int access;        /* wanted access rights */
     int low;                    /* initial value of low word */
     int high;                   /* initial value of high word */
+    int type;                   /* type of fsync object */
     VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
     obj_handle_t handle;        /* handle to the object */
+    int type;                   /* type of fsync object */
     unsigned int shm_idx;       /* this object's index into the shm section */
 @END
 
-- 
2.46.0


From 0696710babf710ed9d0aa01e4bcf998d8cf64374 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 12:02:39 -0500
Subject: [PATCH 25/55] ntdll, server: Implement NtOpenSemaphore().

---
 dlls/ntdll/unix/fsync.c | 40 ++++++++++++++++++++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  2 ++
 dlls/ntdll/unix/sync.c  |  3 +++
 server/fsync.c          | 27 +++++++++++++++++++++++++++
 server/protocol.def     | 13 +++++++++++++
 5 files changed, 85 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index e65abc525ed..81bd29634b1 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -312,6 +312,38 @@ static NTSTATUS create_fsync( enum fsync_type type, HANDLE *handle,
     return ret;
 }
 
+static NTSTATUS open_fsync( enum fsync_type type, HANDLE *handle,
+    ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr )
+{
+    NTSTATUS ret;
+    unsigned int shm_idx;
+
+    SERVER_START_REQ( open_fsync )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->rootdir    = wine_server_obj_handle( attr->RootDirectory );
+        req->type       = type;
+        if (attr->ObjectName)
+            wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
+        if (!(ret = wine_server_call( req )))
+        {
+            *handle = wine_server_ptr_handle( reply->handle );
+            type = reply->type;
+            shm_idx = reply->shm_idx;
+        }
+    }
+    SERVER_END_REQ;
+
+    if (!ret)
+    {
+        add_to_list( *handle, type, get_shm( shm_idx ) );
+
+        TRACE("-> handle %p, shm index %u.\n", *handle, shm_idx);
+    }
+    return ret;
+}
+
 void fsync_init(void)
 {
     struct stat st;
@@ -365,6 +397,14 @@ NTSTATUS fsync_create_semaphore( HANDLE *handle, ACCESS_MASK access,
     return create_fsync( FSYNC_SEMAPHORE, handle, access, attr, initial, max );
 }
 
+NTSTATUS fsync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    return open_fsync( FSYNC_SEMAPHORE, handle, access, attr );
+}
+
 NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 {
     struct fsync *obj;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index c39c3a14e59..b70851499fe 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -25,6 +25,8 @@ extern NTSTATUS fsync_close( HANDLE handle );
 extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, LONG initial, LONG max);
 extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev );
+extern NTSTATUS fsync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
 extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index f476963f74f..8feac6ac727 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -352,6 +352,9 @@ NTSTATUS WINAPI NtOpenSemaphore( HANDLE *handle, ACCESS_MASK access, const OBJEC
 
     *handle = 0;
 
+    if (do_fsync())
+        return fsync_open_semaphore( handle, access, attr );
+
     if (do_esync())
         return esync_open_semaphore( handle, access, attr );
 
diff --git a/server/fsync.c b/server/fsync.c
index d32d5f9c689..3fbc1734735 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -374,6 +374,33 @@ DECL_HANDLER(create_fsync)
     if (root) release_object( root );
 }
 
+DECL_HANDLER(open_fsync)
+{
+    struct unicode_str name = get_req_unicode_str();
+
+    reply->handle = open_object( current->process, req->rootdir, req->access,
+                                 &fsync_ops, &name, req->attributes );
+
+    if (reply->handle)
+    {
+        struct fsync *fsync;
+
+        if (!(fsync = (struct fsync *)get_handle_obj( current->process, reply->handle,
+                                                      0, &fsync_ops )))
+            return;
+
+        if (!type_matches( req->type, fsync->type ))
+        {
+            set_error( STATUS_OBJECT_TYPE_MISMATCH );
+            release_object( fsync );
+            return;
+        }
+
+        reply->type = fsync->type;
+        reply->shm_idx = fsync->shm_idx;
+        release_object( fsync );
+    }
+}
 
 /* Retrieve the index of a shm section which will be signaled by the server. */
 DECL_HANDLER(get_fsync_idx)
diff --git a/server/protocol.def b/server/protocol.def
index 1bf698541dd..110cc679032 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4028,6 +4028,19 @@ enum fsync_type
     unsigned int shm_idx;       /* this object's index into the shm section */
 @END
 
+/* Open an fsync object */
+@REQ(open_fsync)
+    unsigned int access;        /* wanted access rights */
+    unsigned int attributes;    /* object attributes */
+    obj_handle_t rootdir;       /* root directory */
+    int          type;          /* type of fsync object */
+    VARARG(name,unicode_str);   /* object name */
+@REPLY
+    obj_handle_t handle;        /* handle to the event */
+    int          type;          /* type of fsync object */
+    unsigned int shm_idx;       /* this object's index into the shm section */
+@END
+
 /* Retrieve the shm index for an object. */
 @REQ(get_fsync_idx)
     obj_handle_t handle;        /* handle to the object */
-- 
2.46.0


From 3b9b4c7f8a34829883f78156db9f8df91500723a Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 12:05:37 -0500
Subject: [PATCH 26/55] ntdll: Implement NtOpenEvent().

---
 dlls/ntdll/unix/fsync.c | 8 ++++++++
 dlls/ntdll/unix/fsync.h | 2 ++
 dlls/ntdll/unix/sync.c  | 3 +++
 3 files changed, 13 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 81bd29634b1..dfb54c667a8 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -443,6 +443,14 @@ NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     return create_fsync( type, handle, access, attr, initial, 0xdeadbeef );
 }
 
+NTSTATUS fsync_open_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    return open_fsync( FSYNC_AUTO_EVENT, handle, access, attr );
+}
+
 NTSTATUS fsync_set_event( HANDLE handle, LONG *prev )
 {
     struct event *event;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index b70851499fe..9a777ef3521 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -29,6 +29,8 @@ extern NTSTATUS fsync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
+extern NTSTATUS fsync_open_event( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 8feac6ac727..2a148de155b 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -486,6 +486,9 @@ NTSTATUS WINAPI NtOpenEvent( HANDLE *handle, ACCESS_MASK access, const OBJECT_AT
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_fsync())
+        return fsync_open_event( handle, access, attr );
+
     if (do_esync())
         return esync_open_event( handle, access, attr );
 
-- 
2.46.0


From cf891972beee091a9641e96d5f883138cc43c52b Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 12:06:40 -0500
Subject: [PATCH 27/55] ntdll: Implement NtOpenMutant().

---
 dlls/ntdll/unix/fsync.c | 8 ++++++++
 dlls/ntdll/unix/fsync.h | 2 ++
 dlls/ntdll/unix/sync.c  | 3 +++
 3 files changed, 13 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index dfb54c667a8..383df952e4b 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -498,6 +498,14 @@ NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
         initial ? GetCurrentThreadId() : 0, initial ? 1 : 0 );
 }
 
+NTSTATUS fsync_open_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr )
+{
+    TRACE("name %s.\n", debugstr_us(attr->ObjectName));
+
+    return open_fsync( FSYNC_MUTEX, handle, access, attr );
+}
+
 NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev )
 {
     struct mutex *mutex;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 9a777ef3521..0fc2305bd5c 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -35,6 +35,8 @@ extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
+extern NTSTATUS fsync_open_mutex( HANDLE *handle, ACCESS_MASK access,
+    const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 2a148de155b..c4c53eb60d0 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -674,6 +674,9 @@ NTSTATUS WINAPI NtOpenMutant( HANDLE *handle, ACCESS_MASK access, const OBJECT_A
     *handle = 0;
     if ((ret = validate_open_object_attributes( attr ))) return ret;
 
+    if (do_fsync())
+        return fsync_open_mutex( handle, access, attr );
+
     if (do_esync())
         return esync_open_mutex( handle, access, attr );
 
-- 
2.46.0


From fef4425895f27fd3cb5bd80621113c76a4caeaad Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 12:07:48 -0500
Subject: [PATCH 28/55] server: Implement fsync_map_access().

---
 server/fsync.c | 13 ++++++++++++-
 1 file changed, 12 insertions(+), 1 deletion(-)

diff --git a/server/fsync.c b/server/fsync.c
index 3fbc1734735..1df3aff91b6 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -131,6 +131,7 @@ struct fsync
 };
 
 static void fsync_dump( struct object *obj, int verbose );
+static unsigned int fsync_map_access( struct object *obj, unsigned int access );
 static void fsync_destroy( struct object *obj );
 
 const struct object_ops fsync_ops =
@@ -146,7 +147,7 @@ const struct object_ops fsync_ops =
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
-    default_map_access,        /* map_access */
+    fsync_map_access,          /* map_access */
     default_get_sd,            /* get_sd */
     default_set_sd,            /* set_sd */
     default_get_full_name,     /* get_full_name */
@@ -166,6 +167,16 @@ static void fsync_dump( struct object *obj, int verbose )
     fprintf( stderr, "fsync idx=%d\n", fsync->shm_idx );
 }
 
+static unsigned int fsync_map_access( struct object *obj, unsigned int access )
+{
+    /* Sync objects have the same flags. */
+    if (access & GENERIC_READ)    access |= STANDARD_RIGHTS_READ | EVENT_QUERY_STATE;
+    if (access & GENERIC_WRITE)   access |= STANDARD_RIGHTS_WRITE | EVENT_MODIFY_STATE;
+    if (access & GENERIC_EXECUTE) access |= STANDARD_RIGHTS_EXECUTE | SYNCHRONIZE;
+    if (access & GENERIC_ALL)     access |= STANDARD_RIGHTS_ALL | EVENT_QUERY_STATE | EVENT_MODIFY_STATE;
+    return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
+}
+
 static void fsync_destroy( struct object *obj )
 {
 }
-- 
2.46.0


From 4ece173f2146f8dae1d4d0127a266034aefaa8f5 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 12:12:10 -0500
Subject: [PATCH 29/55] ntdll, server: Implement handle duplication.

---
 dlls/ntdll/unix/fsync.c | 16 ++++++++++------
 server/fsync.c          | 10 +++++++++-
 2 files changed, 19 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 383df952e4b..142e3ee284b 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -410,10 +410,11 @@ NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
     struct fsync *obj;
     struct semaphore *semaphore;
     ULONG current;
+    NTSTATUS ret;
 
     TRACE("%p, %d, %p.\n", handle, (int)count, prev);
 
-    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
     semaphore = obj->shm;
 
     do
@@ -456,10 +457,11 @@ NTSTATUS fsync_set_event( HANDLE handle, LONG *prev )
     struct event *event;
     struct fsync *obj;
     LONG current;
+    NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
-    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
     event = obj->shm;
 
     if (!(current = __atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST )))
@@ -475,10 +477,11 @@ NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev )
     struct event *event;
     struct fsync *obj;
     LONG current;
+    NTSTATUS ret;
 
     TRACE("%p.\n", handle);
 
-    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
     event = obj->shm;
 
     current = __atomic_exchange_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
@@ -510,10 +513,11 @@ NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev )
 {
     struct mutex *mutex;
     struct fsync *obj;
+    NTSTATUS ret;
 
     TRACE("%p, %p.\n", handle, prev);
 
-    if (!(obj = get_cached_object( handle ))) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( handle, &obj ))) return ret;
     mutex = obj->shm;
 
     if (mutex->tid != GetCurrentThreadId()) return STATUS_MUTANT_NOT_OWNED;
@@ -974,10 +978,10 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
 NTSTATUS fsync_signal_and_wait( HANDLE signal, HANDLE wait, BOOLEAN alertable,
     const LARGE_INTEGER *timeout )
 {
-    struct fsync *obj = get_cached_object( signal );
+    struct fsync *obj;
     NTSTATUS ret;
 
-    if (!obj) return STATUS_INVALID_HANDLE;
+    if ((ret = get_object( signal, &obj ))) return ret;
 
     switch (obj->type)
     {
diff --git a/server/fsync.c b/server/fsync.c
index 1df3aff91b6..73d1873759b 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -131,6 +131,7 @@ struct fsync
 };
 
 static void fsync_dump( struct object *obj, int verbose );
+static unsigned int fsync_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static unsigned int fsync_map_access( struct object *obj, unsigned int access );
 static void fsync_destroy( struct object *obj );
 
@@ -143,7 +144,7 @@ const struct object_ops fsync_ops =
     NULL,                      /* remove_queue */
     NULL,                      /* signaled */
     NULL,                      /* get_esync_fd */
-    NULL,                      /* get_fsync_idx */
+    fsync_get_fsync_idx,       /* get_fsync_idx */
     NULL,                      /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -167,6 +168,13 @@ static void fsync_dump( struct object *obj, int verbose )
     fprintf( stderr, "fsync idx=%d\n", fsync->shm_idx );
 }
 
+static unsigned int fsync_get_fsync_idx( struct object *obj, enum fsync_type *type)
+{
+    struct fsync *fsync = (struct fsync *)obj;
+    *type = fsync->type;
+    return fsync->shm_idx;
+}
+
 static unsigned int fsync_map_access( struct object *obj, unsigned int access )
 {
     /* Sync objects have the same flags. */
-- 
2.46.0


From 323209b9c0f13ea3b3dacac162c9140732a60fc1 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 2 Sep 2018 13:19:09 -0500
Subject: [PATCH 30/55] ntdll, server: Implement alertable waits.

---
 dlls/ntdll/unix/fsync.c        | 107 +++++++++++++++++++++++++++++----
 dlls/ntdll/unix/unix_private.h |   1 +
 dlls/ntdll/unix/virtual.c      |   1 +
 server/fsync.c                 |  33 ++++++----
 server/fsync.h                 |   2 +
 server/protocol.def            |   5 ++
 server/thread.c                |  10 +++
 server/thread.h                |   1 +
 8 files changed, 135 insertions(+), 25 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 142e3ee284b..9518f1f0960 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -544,20 +544,53 @@ static LONGLONG update_timeout( ULONGLONG end )
     return timeleft;
 }
 
-static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end )
+static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN alertable )
 {
     int ret;
 
-    if (end)
+    if (alertable)
     {
-        LONGLONG timeleft = update_timeout( *end );
-        struct timespec tmo_p;
-        tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-        tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-        ret = futex_wait( addr, val, &tmo_p );
+        struct event *apc_event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
+        struct futex_wait_block futexes[2];
+
+        if (__atomic_load_n( &apc_event->signaled, __ATOMIC_SEQ_CST ))
+            return STATUS_USER_APC;
+
+        futexes[0].addr = addr;
+        futexes[0].val = val;
+        futexes[1].addr = &apc_event->signaled;
+        futexes[1].val = 0;
+#if __SIZEOF_POINTER__ == 4
+        futexes[0].pad = futexes[1].pad = 0;
+#endif
+
+        if (end)
+        {
+            LONGLONG timeleft = update_timeout( *end );
+            struct timespec tmo_p;
+            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+            ret = futex_wait_multiple( futexes, 2, &tmo_p );
+        }
+        else
+            ret = futex_wait_multiple( futexes, 2, NULL );
+
+        if (__atomic_load_n( &apc_event->signaled, __ATOMIC_SEQ_CST ))
+            return STATUS_USER_APC;
     }
     else
-        ret = futex_wait( addr, val, NULL );
+    {
+        if (end)
+        {
+            LONGLONG timeleft = update_timeout( *end );
+            struct timespec tmo_p;
+            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+            ret = futex_wait( addr, val, &tmo_p );
+        }
+        else
+            ret = futex_wait( addr, val, NULL );
+    }
 
     if (!ret)
         return 0;
@@ -570,16 +603,30 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end )
 static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
-    struct futex_wait_block futexes[MAXIMUM_WAIT_OBJECTS];
+    static const LARGE_INTEGER zero = {0};
+
+    struct futex_wait_block futexes[MAXIMUM_WAIT_OBJECTS + 1];
     struct fsync *objs[MAXIMUM_WAIT_OBJECTS];
     int has_fsync = 0, has_server = 0;
     BOOL msgwait = FALSE;
     int dummy_futex = 0;
     LONGLONG timeleft;
     LARGE_INTEGER now;
+    DWORD waitcount;
     ULONGLONG end;
     int i, ret;
 
+    /* Grab the APC futex if we don't already have it. */
+    if (alertable && !ntdll_get_thread_data()->fsync_apc_idx)
+    {
+        SERVER_START_REQ( get_fsync_apc_idx )
+        {
+            if (!(ret = wine_server_call( req )))
+                ntdll_get_thread_data()->fsync_apc_idx = reply->shm_idx;
+        }
+        SERVER_END_REQ;
+    }
+
     NtQuerySystemTime( &now );
     if (timeout)
     {
@@ -618,6 +665,8 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 
         if (msgwait)
             TRACE(" or driver events");
+        if (alertable)
+            TRACE(", alertable");
 
         if (!timeout)
             TRACE(", timeout = INFINITE.\n");
@@ -731,6 +780,21 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 #endif
             }
 
+            if (alertable)
+            {
+                struct event *event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
+                if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                    goto userapc;
+
+                futexes[i].addr = &event->signaled;
+                futexes[i].val = 0;
+#if __SIZEOF_POINTER__ == 4
+                futexes[i].pad = 0;
+#endif
+                i++;
+            }
+            waitcount = i;
+
             /* Looks like everything is contended, so wait. */
 
             if (timeout)
@@ -740,10 +804,10 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
                 tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
 
-                ret = futex_wait_multiple( futexes, count, &tmo_p );
+                ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
             }
             else
-                ret = futex_wait_multiple( futexes, count, NULL );
+                ret = futex_wait_multiple( futexes, waitcount, NULL );
 
             /* FUTEX_WAIT_MULTIPLE can succeed or return -EINTR, -EAGAIN,
              * -EFAULT/-EACCES, -ETIMEDOUT. In the first three cases we need to
@@ -800,7 +864,7 @@ tryagain:
 
                     while ((current = __atomic_load_n( &mutex->tid, __ATOMIC_SEQ_CST )))
                     {
-                        status = do_single_wait( &mutex->tid, current, timeout ? &end : NULL );
+                        status = do_single_wait( &mutex->tid, current, timeout ? &end : NULL, alertable );
                         if (status != STATUS_PENDING)
                             break;
                     }
@@ -812,7 +876,7 @@ tryagain:
 
                     while (!__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
                     {
-                        status = do_single_wait( &event->signaled, 0, timeout ? &end : NULL );
+                        status = do_single_wait( &event->signaled, 0, timeout ? &end : NULL, alertable );
                         if (status != STATUS_PENDING)
                             break;
                     }
@@ -823,6 +887,8 @@ tryagain:
                     TRACE("Wait timed out.\n");
                     return status;
                 }
+                else if (status == STATUS_USER_APC)
+                    goto userapc;
             }
 
             /* If we got here and we haven't timed out, that means all of the
@@ -931,6 +997,21 @@ tooslow:
             }
         } /* while (1) */
     } /* else (wait-all) */
+
+    assert(0);  /* shouldn't reach here... */
+
+userapc:
+    TRACE("Woken up by user APC.\n");
+
+    /* We have to make a server call anyway to get the APC to execute, so just
+     * delegate down to server_wait(). */
+    ret = server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, &zero );
+
+    /* This can happen if we received a system APC, and the APC fd was woken up
+     * before we got SIGUSR1. poll() doesn't return EINTR in that case. The
+     * right thing to do seems to be to return STATUS_USER_APC anyway. */
+    if (ret == STATUS_TIMEOUT) ret = STATUS_USER_APC;
+    return ret;
 }
 
 /* Like esync, we need to let the server know when we are doing a message wait,
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 8fbb64b4d95..c487ef487f0 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -104,6 +104,7 @@ struct ntdll_thread_data
     void              *cpu_data[16];  /* reserved for CPU-specific data */
     void              *kernel_stack;  /* stack for thread startup and kernel syscalls */
     int                esync_apc_fd;  /* fd to wait on for user APCs */
+    unsigned int       fsync_apc_idx;
     int                request_fd;    /* fd for sending server requests */
     int                reply_fd;      /* fd for receiving server replies */
     int                wait_fd[2];    /* fd for sleeping server requests */
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index e7f18ca327c..3bcdd6c11c1 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -3683,6 +3683,7 @@ static TEB *init_teb( void *ptr, BOOL is_wow )
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
     thread_data->esync_apc_fd = -1;
+    thread_data->fsync_apc_idx = 0;
     thread_data->request_fd = -1;
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
diff --git a/server/fsync.c b/server/fsync.c
index 73d1873759b..10d8eb74bc3 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -316,31 +316,35 @@ struct fsync_event
     int unused;
 };
 
+void fsync_wake_futex( unsigned int shm_idx )
+{
+    struct fsync_event *event = get_shm( shm_idx );
+
+    if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
+        futex_wake( &event->signaled, INT_MAX );
+}
+
 void fsync_wake_up( struct object *obj )
 {
-    struct fsync_event *event;
     enum fsync_type type;
 
     if (obj->ops->get_fsync_idx)
-    {
-        event = get_shm( obj->ops->get_fsync_idx( obj, &type ) );
+        fsync_wake_futex( obj->ops->get_fsync_idx( obj, &type ) );
+}
 
-        if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
-            futex_wake( &event->signaled, INT_MAX );
-    }
+void fsync_clear_futex( unsigned int shm_idx )
+{
+    struct fsync_event *event = get_shm( shm_idx );
+
+    __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
 }
 
 void fsync_clear( struct object *obj )
 {
-    struct fsync_event *event;
     enum fsync_type type;
 
     if (obj->ops->get_fsync_idx)
-    {
-        event = get_shm( obj->ops->get_fsync_idx( obj, &type ) );
-
-        __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
-    }
+        fsync_clear_futex( obj->ops->get_fsync_idx( obj, &type ) );
 }
 
 void fsync_set_event( struct fsync *fsync )
@@ -447,3 +451,8 @@ DECL_HANDLER(get_fsync_idx)
 
     release_object( obj );
 }
+
+DECL_HANDLER(get_fsync_apc_idx)
+{
+    reply->shm_idx = current->fsync_apc_idx;
+}
diff --git a/server/fsync.h b/server/fsync.h
index 087d482717b..f6f1a48b31e 100644
--- a/server/fsync.h
+++ b/server/fsync.h
@@ -21,6 +21,8 @@
 extern int do_fsync(void);
 extern void fsync_init(void);
 extern unsigned int fsync_alloc_shm( int low, int high );
+extern void fsync_wake_futex( unsigned int shm_idx );
+extern void fsync_clear_futex( unsigned int shm_idx );
 extern void fsync_wake_up( struct object *obj );
 extern void fsync_clear( struct object *obj );
 
diff --git a/server/protocol.def b/server/protocol.def
index 110cc679032..7b64fc3d3ce 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4052,3 +4052,8 @@ enum fsync_type
 @REQ(fsync_msgwait)
     int          in_msgwait;    /* are we in a message wait? */
 @END
+
+@REQ(get_fsync_apc_idx)
+@REPLY
+    unsigned int shm_idx;
+@END
diff --git a/server/thread.c b/server/thread.c
index 2985d212cde..321d6e74c7d 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -387,7 +387,10 @@ struct thread *create_thread( int fd, struct process *process, const struct secu
     }
 
     if (do_fsync())
+    {
         thread->fsync_idx = fsync_alloc_shm( 0, 0 );
+        thread->fsync_apc_idx = fsync_alloc_shm( 0, 0 );
+    }
 
     if (do_esync())
     {
@@ -561,6 +564,7 @@ static struct thread_apc *create_apc( struct object *owner, const apc_call_t *ca
         apc->result.type = APC_NONE;
         if (owner) grab_object( owner );
     }
+
     return apc;
 }
 
@@ -1197,6 +1201,9 @@ static int queue_apc( struct process *process, struct thread *thread, struct thr
     {
         wake_thread( thread );
 
+        if (do_fsync() && queue == &thread->user_apc)
+            fsync_wake_futex( thread->fsync_apc_idx );
+
         if (do_esync() && queue == &thread->user_apc)
             esync_wake_fd( thread->esync_apc_fd );
     }
@@ -1247,6 +1254,9 @@ static struct thread_apc *thread_dequeue_apc( struct thread *thread, int system
         list_remove( ptr );
     }
 
+    if (do_fsync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
+        fsync_clear_futex( thread->fsync_apc_idx );
+
     if (do_esync() && list_empty( &thread->system_apc ) && list_empty( &thread->user_apc ))
         esync_clear( thread->esync_apc_fd );
 
diff --git a/server/thread.h b/server/thread.h
index 8ca234fc65a..2722aed3587 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -58,6 +58,7 @@ struct thread
     int                    esync_fd;      /* esync file descriptor (signalled on exit) */
     int                    esync_apc_fd;  /* esync apc fd (signalled when APCs are present) */
     unsigned int           fsync_idx;
+    unsigned int           fsync_apc_idx;
     unsigned int           system_regs;   /* which system regs have been set */
     struct msg_queue      *queue;         /* message queue */
     struct thread_wait    *wait;          /* current wait condition if sleeping */
-- 
2.46.0


From 585eba4a8966f0a1add05b3b3bb6fd114701d438 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 3 Mar 2019 10:45:10 -0600
Subject: [PATCH 31/55] ntdll: Wake all threads in futex_wake().

Because wait-all exists, this unfortunately seems necessary.
---
 dlls/ntdll/unix/fsync.c | 7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 9518f1f0960..690898f7eac 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -426,8 +426,7 @@ NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
 
     if (prev) *prev = current;
 
-    if (!current)
-        futex_wake( &semaphore->count, count );
+    futex_wake( &semaphore->count, INT_MAX );
 
     return STATUS_SUCCESS;
 }
@@ -465,7 +464,7 @@ NTSTATUS fsync_set_event( HANDLE handle, LONG *prev )
     event = obj->shm;
 
     if (!(current = __atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST )))
-        futex_wake( &event->signaled, obj->type == FSYNC_AUTO_EVENT ? 1 : INT_MAX );
+        futex_wake( &event->signaled, INT_MAX );
 
     if (prev) *prev = current;
 
@@ -527,7 +526,7 @@ NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev )
     if (!--mutex->count)
     {
         __atomic_store_n( &mutex->tid, 0, __ATOMIC_SEQ_CST );
-        futex_wake( &mutex->tid, 1 );
+        futex_wake( &mutex->tid, INT_MAX );
     }
 
     return STATUS_SUCCESS;
-- 
2.46.0


From 67de78b4519fd4d1e90e6471f130c585de0dc967 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 3 Mar 2019 11:02:28 -0600
Subject: [PATCH 32/55] server: Create futex sections for timer objects.

---
 dlls/ntdll/unix/fsync.c |  3 +++
 server/protocol.def     |  1 +
 server/timer.c          | 18 +++++++++++++++++-
 3 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 690898f7eac..f2ae70ee1ab 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -734,6 +734,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         break;
                     }
                     case FSYNC_AUTO_EVENT:
+                    case FSYNC_AUTO_SERVER:
                     {
                         struct event *event = obj->shm;
 
@@ -938,6 +939,7 @@ tryagain:
                     break;
                 }
                 case FSYNC_AUTO_EVENT:
+                case FSYNC_AUTO_SERVER:
                 {
                     struct event *event = obj->shm;
                     if (!__sync_val_compare_and_swap( &event->signaled, 1, 0 ))
@@ -984,6 +986,7 @@ tooslow:
                     break;
                 }
                 case FSYNC_AUTO_EVENT:
+                case FSYNC_AUTO_SERVER:
                 {
                     struct event *event = obj->shm;
                     __atomic_store_n( &event->signaled, 1, __ATOMIC_SEQ_CST );
diff --git a/server/protocol.def b/server/protocol.def
index 7b64fc3d3ce..f867ec53761 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -4011,6 +4011,7 @@ enum fsync_type
     FSYNC_AUTO_EVENT,
     FSYNC_MANUAL_EVENT,
     FSYNC_MUTEX,
+    FSYNC_AUTO_SERVER,
     FSYNC_MANUAL_SERVER,
     FSYNC_QUEUE,
 };
diff --git a/server/timer.c b/server/timer.c
index 9ec9604aa0e..afc12ff03ad 100644
--- a/server/timer.c
+++ b/server/timer.c
@@ -36,6 +36,7 @@
 #include "handle.h"
 #include "request.h"
 #include "esync.h"
+#include "fsync.h"
 
 static const WCHAR timer_name[] = {'T','i','m','e','r'};
 
@@ -63,11 +64,13 @@ struct timer
     client_ptr_t         callback;  /* callback APC function */
     client_ptr_t         arg;       /* callback argument */
     int                  esync_fd;  /* esync file descriptor */
+    unsigned int         fsync_idx; /* fsync shm index */
 };
 
 static void timer_dump( struct object *obj, int verbose );
 static int timer_signaled( struct object *obj, struct wait_queue_entry *entry );
 static int timer_get_esync_fd( struct object *obj, enum esync_type *type );
+static unsigned int timer_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry );
 static void timer_destroy( struct object *obj );
 
@@ -80,7 +83,7 @@ static const struct object_ops timer_ops =
     remove_queue,              /* remove_queue */
     timer_signaled,            /* signaled */
     timer_get_esync_fd,        /* get_esync_fd */
-    NULL,                      /* get_fsync_idx */
+    timer_get_fsync_idx,       /* get_fsync_idx */
     timer_satisfied,           /* satisfied */
     no_signal,                 /* signal */
     no_get_fd,                 /* get_fd */
@@ -117,6 +120,9 @@ static struct timer *create_timer( struct object *root, const struct unicode_str
             timer->thread   = NULL;
             timer->esync_fd = -1;
 
+            if (do_fsync())
+                timer->fsync_idx = fsync_alloc_shm( 0, 0 );
+
             if (do_esync())
                 timer->esync_fd = esync_create_fd( 0, 0 );
         }
@@ -191,6 +197,9 @@ static int set_timer( struct timer *timer, timeout_t expire, unsigned int period
         period = 0;  /* period doesn't make any sense for a manual timer */
         timer->signaled = 0;
 
+        if (do_fsync())
+            fsync_clear( &timer->obj );
+
         if (do_esync())
             esync_clear( timer->esync_fd );
     }
@@ -227,6 +236,13 @@ static int timer_get_esync_fd( struct object *obj, enum esync_type *type )
     return timer->esync_fd;
 }
 
+static unsigned int timer_get_fsync_idx( struct object *obj, enum fsync_type *type )
+{
+    struct timer *timer = (struct timer *)obj;
+    *type = timer->manual ? FSYNC_MANUAL_SERVER : FSYNC_AUTO_SERVER;
+    return timer->fsync_idx;
+}
+
 static void timer_satisfied( struct object *obj, struct wait_queue_entry *entry )
 {
     struct timer *timer = (struct timer *)obj;
-- 
2.46.0


From 7dbe60d8e6f0cd92e3656e9f71f7e9630e8e1de0 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 3 Mar 2019 11:23:23 -0600
Subject: [PATCH 33/55] ntdll: Implement NtQuerySemaphore().

---
 dlls/ntdll/unix/fsync.c | 19 +++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 23 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index f2ae70ee1ab..fb51a55aed7 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -431,6 +431,25 @@ NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len )
+{
+    struct fsync *obj;
+    struct semaphore *semaphore;
+    SEMAPHORE_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    semaphore = obj->shm;
+
+    out->CurrentCount = semaphore->count;
+    out->MaximumCount = semaphore->max;
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE event_type, BOOLEAN initial )
 {
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 0fc2305bd5c..72a36d4517e 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -27,6 +27,7 @@ extern NTSTATUS fsync_create_semaphore(HANDLE *handle, ACCESS_MASK access,
 extern NTSTATUS fsync_release_semaphore( HANDLE handle, ULONG count, ULONG *prev );
 extern NTSTATUS fsync_open_semaphore( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr );
+extern NTSTATUS fsync_query_semaphore( HANDLE handle, void *info, ULONG *ret_len );
 extern NTSTATUS fsync_create_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, EVENT_TYPE type, BOOLEAN initial );
 extern NTSTATUS fsync_open_event( HANDLE *handle, ACCESS_MASK access,
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index c4c53eb60d0..f44650ccf00 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -394,6 +394,9 @@ NTSTATUS WINAPI NtQuerySemaphore( HANDLE handle, SEMAPHORE_INFORMATION_CLASS cla
 
     if (len != sizeof(SEMAPHORE_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if (do_fsync())
+        return fsync_query_semaphore( handle, info, ret_len );
+
     if (do_esync())
         return esync_query_semaphore( handle, info, ret_len );
 
-- 
2.46.0


From 36e18dab83cf2998c0aaeca2f5006130a5e87d1d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 6 Jul 2020 20:11:08 -0500
Subject: [PATCH 34/55] ntdll: Implement NtQueryEvent().

---
 dlls/ntdll/unix/fsync.c | 19 +++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 23 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index fb51a55aed7..3cb8cb50d36 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -509,6 +509,25 @@ NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_query_event( HANDLE handle, void *info, ULONG *ret_len )
+{
+    struct event *event;
+    struct fsync *obj;
+    EVENT_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    event = obj->shm;
+
+    out->EventState = event->signaled;
+    out->EventType = (obj->type == FSYNC_AUTO_EVENT ? SynchronizationEvent : NotificationEvent);
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial )
 {
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 72a36d4517e..388ae479eed 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -34,6 +34,7 @@ extern NTSTATUS fsync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
+extern NTSTATUS fsync_query_event( HANDLE handle, void *info, ULONG *ret_len );
 extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
 extern NTSTATUS fsync_open_mutex( HANDLE *handle, ACCESS_MASK access,
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index f44650ccf00..1f883493d96 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -614,6 +614,9 @@ NTSTATUS WINAPI NtQueryEvent( HANDLE handle, EVENT_INFORMATION_CLASS class,
 
     if (len != sizeof(EVENT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if (do_fsync())
+        return fsync_query_event( handle, info, ret_len );
+
     if (do_esync())
         return esync_query_event( handle, info, ret_len );
 
-- 
2.46.0


From 0c5af2162521dd5485595e3876f650efec3d1fc4 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 3 Mar 2019 11:29:55 -0600
Subject: [PATCH 35/55] ntdll: Implement NtQueryMutant().

---
 dlls/ntdll/unix/fsync.c | 20 ++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 24 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 3cb8cb50d36..522803268dc 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -570,6 +570,26 @@ NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
+{
+    struct fsync *obj;
+    struct mutex *mutex;
+    MUTANT_BASIC_INFORMATION *out = info;
+    NTSTATUS ret;
+
+    TRACE("handle %p, info %p, ret_len %p.\n", handle, info, ret_len);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    mutex = obj->shm;
+
+    out->CurrentCount = 1 - mutex->count;
+    out->OwnedByCaller = (mutex->tid == GetCurrentThreadId());
+    out->AbandonedState = FALSE;
+    if (ret_len) *ret_len = sizeof(*out);
+
+    return STATUS_SUCCESS;
+}
+
 static LONGLONG update_timeout( ULONGLONG end )
 {
     LARGE_INTEGER now;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 388ae479eed..fe354b39dad 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -40,6 +40,7 @@ extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
 extern NTSTATUS fsync_open_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_release_mutex( HANDLE handle, LONG *prev );
+extern NTSTATUS fsync_query_mutex( HANDLE handle, void *info, ULONG *ret_len );
 
 extern NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_any,
                                     BOOLEAN alertable, const LARGE_INTEGER *timeout );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 1f883493d96..99edee33b63 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -744,6 +744,9 @@ NTSTATUS WINAPI NtQueryMutant( HANDLE handle, MUTANT_INFORMATION_CLASS class,
 
     if (len != sizeof(MUTANT_BASIC_INFORMATION)) return STATUS_INFO_LENGTH_MISMATCH;
 
+    if (do_fsync())
+        return fsync_query_mutex( handle, info, ret_len );
+
     if (do_esync())
         return esync_query_mutex( handle, info, ret_len );
 
-- 
2.46.0


From 55d98bb874643f57c1dd155394d5bf6ebd004489 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 3 Mar 2019 11:35:22 -0600
Subject: [PATCH 36/55] server: Create futex sections for pseudo-fd objects and
 use them for named pipes.

---
 server/fd.c         | 18 ++++++++++++++++++
 server/file.h       |  1 +
 server/named_pipe.c |  4 ++--
 3 files changed, 21 insertions(+), 2 deletions(-)

diff --git a/server/fd.c b/server/fd.c
index 509f0b42534..8fe4d5f1d56 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -97,6 +97,7 @@
 #include "process.h"
 #include "request.h"
 #include "esync.h"
+#include "fsync.h"
 
 #include "winternl.h"
 #include "winioctl.h"
@@ -158,6 +159,7 @@ struct fd
     apc_param_t          comp_key;    /* completion key to set in completion events */
     unsigned int         comp_flags;  /* completion flags */
     int                  esync_fd;    /* esync file descriptor */
+    unsigned int         fsync_idx;   /* fsync shm index */
 };
 
 static void fd_dump( struct object *obj, int verbose );
@@ -1748,8 +1750,12 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     list_init( &fd->inode_entry );
     list_init( &fd->locks );
 
+    if (do_fsync())
+        fd->fsync_idx = fsync_alloc_shm( 0, 0 );
+
     if (do_esync())
         fd->esync_fd = esync_create_fd( 0, 0 );
+
     return fd;
 }
 
@@ -2162,6 +2168,9 @@ void set_fd_signaled( struct fd *fd, int signaled )
     fd->signaled = signaled;
     if (signaled) wake_up( fd->user, 0 );
 
+    if (do_fsync() && !signaled)
+        fsync_clear( &fd->obj );
+
     if (do_esync() && !signaled)
         esync_clear( fd->esync_fd );
 }
@@ -2198,6 +2207,15 @@ int default_fd_get_esync_fd( struct object *obj, enum esync_type *type )
     return ret;
 }
 
+unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type )
+{
+    struct fd *fd = get_obj_fd( obj );
+    unsigned int ret = fd->fsync_idx;
+    *type = FSYNC_MANUAL_SERVER;
+    release_object( fd );
+    return ret;
+}
+
 int default_fd_get_poll_events( struct fd *fd )
 {
     int events = 0;
diff --git a/server/file.h b/server/file.h
index 86467a6a158..d7bed58eafc 100644
--- a/server/file.h
+++ b/server/file.h
@@ -109,6 +109,7 @@ extern void get_nt_name( struct fd *fd, struct unicode_str *name );
 
 extern int default_fd_signaled( struct object *obj, struct wait_queue_entry *entry );
 extern int default_fd_get_esync_fd( struct object *obj, enum esync_type *type );
+extern unsigned int default_fd_get_fsync_idx( struct object *obj, enum fsync_type *type );
 extern int default_fd_get_poll_events( struct fd *fd );
 extern void default_poll_event( struct fd *fd, int event );
 extern void fd_cancel_async( struct fd *fd, struct async *async );
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 0ad89f869f6..4dec855164c 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -170,7 +170,7 @@ static const struct object_ops pipe_server_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     default_fd_get_esync_fd,      /* get_esync_fd */
-    NULL,                         /* get_fsync_idx */
+    default_fd_get_fsync_idx,     /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
@@ -216,7 +216,7 @@ static const struct object_ops pipe_client_ops =
     remove_queue,                 /* remove_queue */
     default_fd_signaled,          /* signaled */
     default_fd_get_esync_fd,      /* get_esync_fd */
-    NULL,                         /* get_fsync_idx */
+    default_fd_get_fsync_idx,     /* get_fsync_idx */
     no_satisfied,                 /* satisfied */
     no_signal,                    /* signal */
     pipe_end_get_fd,              /* get_fd */
-- 
2.46.0


From e08f19a00595af26ab90b721db04459d956c2d52 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Sun, 3 Mar 2019 11:44:00 -0600
Subject: [PATCH 37/55] server: Create futex sections for true file objects and
 use them for directory change notifications.

---
 server/change.c |  2 +-
 server/fd.c     |  3 +++
 server/fsync.c  | 13 ++++++++++++-
 3 files changed, 16 insertions(+), 2 deletions(-)

diff --git a/server/change.c b/server/change.c
index 215db47f11e..5611dfe292c 100644
--- a/server/change.c
+++ b/server/change.c
@@ -113,7 +113,7 @@ static const struct object_ops dir_ops =
     remove_queue,             /* remove_queue */
     default_fd_signaled,      /* signaled */
     default_fd_get_esync_fd,  /* get_esync_fd */
-    NULL,                     /* get_fsync_idx */
+    default_fd_get_fsync_idx, /* get_fsync_idx */
     no_satisfied,             /* satisfied */
     no_signal,                /* signal */
     dir_get_fd,               /* get_fd */
diff --git a/server/fd.c b/server/fd.c
index 8fe4d5f1d56..6752828932a 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -1708,6 +1708,9 @@ static struct fd *alloc_fd_object(void)
     if (do_esync())
         fd->esync_fd = esync_create_fd( 1, 0 );
 
+    if (do_fsync())
+        fd->fsync_idx = fsync_alloc_shm( 1, 0 );
+
     if ((fd->poll_index = add_poll_user( fd )) == -1)
     {
         release_object( fd );
diff --git a/server/fsync.c b/server/fsync.c
index 10d8eb74bc3..6a67d22d14e 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -85,6 +85,8 @@ static void **shm_addrs;
 static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
+static int is_fsync_initialized;
+
 static void shm_cleanup(void)
 {
     close( shm_fd );
@@ -120,6 +122,8 @@ void fsync_init(void)
     if (ftruncate( shm_fd, shm_size ) == -1)
         perror( "ftruncate" );
 
+    is_fsync_initialized = 1;
+
     atexit( shm_cleanup );
 }
 
@@ -231,9 +235,16 @@ static unsigned int shm_idx_counter = 1;
 unsigned int fsync_alloc_shm( int low, int high )
 {
 #ifdef __linux__
-    int shm_idx = shm_idx_counter++;
+    int shm_idx;
     int *shm;
 
+    /* this is arguably a bit of a hack, but we need some way to prevent
+     * allocating shm for the master socket */
+    if (!is_fsync_initialized)
+        return 0;
+
+    shm_idx = shm_idx_counter++;
+
     while (shm_idx * 8 >= shm_size)
     {
         /* Better expand the shm section. */
-- 
2.46.0


From 22d0fc8689d84c1266f8ade8639b2a3d1050d347 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Tue, 4 Jun 2019 12:29:31 -0500
Subject: [PATCH 38/55] ntdll: Skip zero-length waits.

An optimization that avoids a syscall.
---
 dlls/ntdll/unix/fsync.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 522803268dc..30c996a6329 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -855,7 +855,14 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 
             /* Looks like everything is contended, so wait. */
 
-            if (timeout)
+            if (timeout && !timeout->QuadPart)
+            {
+                /* Unlike esync, we already know that we've timed out, so we
+                 * can avoid a syscall. */
+                TRACE("Wait timed out.\n");
+                return STATUS_TIMEOUT;
+            }
+            else if (timeout)
             {
                 LONGLONG timeleft = update_timeout( end );
                 struct timespec tmo_p;
-- 
2.46.0


From 00bb8d1c823a1cf8d2abbbd351558e2fe9f6a99f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2019 12:58:27 -0500
Subject: [PATCH 39/55] server: Add a diagnostic message for fsync.

---
 server/fsync.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/server/fsync.c b/server/fsync.c
index 6a67d22d14e..d4dbd66d22a 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -124,6 +124,8 @@ void fsync_init(void)
 
     is_fsync_initialized = 1;
 
+    fprintf( stderr, "fsync: up and running.\n" );
+
     atexit( shm_cleanup );
 }
 
-- 
2.46.0


From 8fa98738f38f36d1b5c61edab0cb26bb53cdda58 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 13 Jun 2019 12:59:53 -0500
Subject: [PATCH 40/55] ntdll, server: Make extra sure that esync is never used
 if fsync is used.

---
 dlls/ntdll/unix/esync.c | 3 ++-
 server/esync.c          | 3 ++-
 2 files changed, 4 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 34c4169784e..57806b54673 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -51,6 +51,7 @@
 
 #include "unix_private.h"
 #include "esync.h"
+#include "fsync.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(esync);
 
@@ -60,7 +61,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
 
     return do_esync_cached;
 #else
diff --git a/server/esync.c b/server/esync.c
index 064bdd61b25..a5164435ed6 100644
--- a/server/esync.c
+++ b/server/esync.c
@@ -43,6 +43,7 @@
 #include "request.h"
 #include "file.h"
 #include "esync.h"
+#include "fsync.h"
 
 int do_esync(void)
 {
@@ -50,7 +51,7 @@ int do_esync(void)
     static int do_esync_cached = -1;
 
     if (do_esync_cached == -1)
-        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC"));
+        do_esync_cached = getenv("WINEESYNC") && atoi(getenv("WINEESYNC")) && !do_fsync();
 
     return do_esync_cached;
 #else
-- 
2.46.0


From bd52e644beab699ff1baab23525f1b4eecb2fa9d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 17 Jul 2019 15:29:04 -0500
Subject: [PATCH 41/55] ntdll, server: Switch to testing ABI.

---
 dlls/ntdll/unix/fsync.c | 6 +++++-
 server/fsync.c          | 2 +-
 2 files changed, 6 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 30c996a6329..885633296a4 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -60,13 +60,14 @@ struct futex_wait_block
     int pad;
 #endif
     int val;
+    int bitset;
 };
 #include "poppack.h"
 
 static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
         int count, const struct timespec *timeout )
 {
-    return syscall( __NR_futex, futexes, 13, count, timeout, 0, 0 );
+    return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
 }
 
 static inline int futex_wake( int *addr, int val )
@@ -620,6 +621,7 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN aler
 #if __SIZEOF_POINTER__ == 4
         futexes[0].pad = futexes[1].pad = 0;
 #endif
+        futexes[0].bitset = futexes[1].bitset = ~0;
 
         if (end)
         {
@@ -836,6 +838,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 #if __SIZEOF_POINTER__ == 4
                 futexes[i].pad = 0;
 #endif
+                futexes[i].bitset = ~0;
             }
 
             if (alertable)
@@ -849,6 +852,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 #if __SIZEOF_POINTER__ == 4
                 futexes[i].pad = 0;
 #endif
+                futexes[i].bitset = ~0;
                 i++;
             }
             waitcount = i;
diff --git a/server/fsync.c b/server/fsync.c
index d4dbd66d22a..2cb804517dc 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -57,7 +57,7 @@ struct futex_wait_block
 static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
         int count, const struct timespec *timeout )
 {
-    return syscall( __NR_futex, futexes, 13, count, timeout, 0, 0 );
+    return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
 }
 
 int do_fsync(void)
-- 
2.46.0


From d5d97970f6a141e04eea6e0953c153d87abb5356 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Tue, 23 Jul 2019 17:22:44 -0500
Subject: [PATCH 42/55] ntdll: Check the APC futex first.

---
 dlls/ntdll/unix/fsync.c | 14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 885633296a4..92c8bb4b7ef 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -743,6 +743,16 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
         {
             /* Try to grab anything. */
 
+            if (alertable)
+            {
+                /* We must check this first! The server may set an event that
+                 * we're waiting on, but we need to return STATUS_USER_APC. */
+                struct event *event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
+                TRACE("...%d\n", __atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ));
+                if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                    goto userapc;
+            }
+
             for (i = 0; i < count; i++)
             {
                 struct fsync *obj = objs[i];
@@ -844,9 +854,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
             if (alertable)
             {
                 struct event *event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
-                if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
-                    goto userapc;
-
+                /* We already checked if it was signaled; don't bother doing it again. */
                 futexes[i].addr = &event->signaled;
                 futexes[i].val = 0;
 #if __SIZEOF_POINTER__ == 4
-- 
2.46.0


From 855a712b28faacdb82b3fd5de696e4d8388616f3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 24 Jul 2019 14:45:24 -0500
Subject: [PATCH 43/55] server: Be a little more careful about futex
 operations.

---
 server/fd.c    |  2 ++
 server/fsync.c | 24 ++++++++++++++++++++++--
 2 files changed, 24 insertions(+), 2 deletions(-)

diff --git a/server/fd.c b/server/fd.c
index 6752828932a..dee6fa889fd 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -1699,6 +1699,7 @@ static struct fd *alloc_fd_object(void)
     fd->completion = NULL;
     fd->comp_flags = 0;
     fd->esync_fd   = -1;
+    fd->fsync_idx  = 0;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
@@ -1747,6 +1748,7 @@ struct fd *alloc_pseudo_fd( const struct fd_ops *fd_user_ops, struct object *use
     fd->comp_flags = 0;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
     fd->esync_fd   = -1;
+    fd->fsync_idx  = 0;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
     init_async_queue( &fd->wait_q );
diff --git a/server/fsync.c b/server/fsync.c
index 2cb804517dc..ca57d7f9cb8 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -331,8 +331,15 @@ struct fsync_event
 
 void fsync_wake_futex( unsigned int shm_idx )
 {
-    struct fsync_event *event = get_shm( shm_idx );
+    struct fsync_event *event;
 
+    if (debug_level)
+        fprintf( stderr, "fsync_wake_futex: index %u\n", shm_idx );
+
+    if (!shm_idx)
+        return;
+
+    event = get_shm( shm_idx );
     if (!__atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST ))
         futex_wake( &event->signaled, INT_MAX );
 }
@@ -341,14 +348,24 @@ void fsync_wake_up( struct object *obj )
 {
     enum fsync_type type;
 
+    if (debug_level)
+        fprintf( stderr, "fsync_wake_up: object %p\n", obj );
+
     if (obj->ops->get_fsync_idx)
         fsync_wake_futex( obj->ops->get_fsync_idx( obj, &type ) );
 }
 
 void fsync_clear_futex( unsigned int shm_idx )
 {
-    struct fsync_event *event = get_shm( shm_idx );
+    struct fsync_event *event;
 
+    if (debug_level)
+        fprintf( stderr, "fsync_clear_futex: index %u\n", shm_idx );
+
+    if (!shm_idx)
+        return;
+
+    event = get_shm( shm_idx );
     __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
 }
 
@@ -356,6 +373,9 @@ void fsync_clear( struct object *obj )
 {
     enum fsync_type type;
 
+    if (debug_level)
+        fprintf( stderr, "fsync_clear: object %p\n", obj );
+
     if (obj->ops->get_fsync_idx)
         fsync_clear_futex( obj->ops->get_fsync_idx( obj, &type ) );
 }
-- 
2.46.0


From 1ca5a086e7f01aec772e9f99c007f8a8207cbe80 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 24 Jul 2019 15:02:01 -0500
Subject: [PATCH 44/55] ntdll: Catch closed handles more gracefully.

---
 dlls/ntdll/unix/fsync.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 92c8bb4b7ef..af0d688b85c 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -759,6 +759,13 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 
                 if (obj)
                 {
+                    if (!obj->type) /* gcc complains if we put this in the switch */
+                    {
+                        /* Someone probably closed an object while waiting on it. */
+                        WARN("Handle %p has type 0; was it closed?\n", handles[i]);
+                        return STATUS_INVALID_HANDLE;
+                    }
+
                     switch (obj->type)
                     {
                     case FSYNC_SEMAPHORE:
@@ -835,6 +842,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         break;
                     }
                     default:
+                        ERR("Invalid type %#x for handle %p.\n", obj->type, handles[i]);
                         assert(0);
                     }
                 }
-- 
2.46.0


From e3356f828a0aa86c42b3f75e5d07238bf57c521f Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 24 Jul 2019 15:04:08 -0500
Subject: [PATCH 45/55] ntdll: Implement fsync_pulse_event().

---
 dlls/ntdll/unix/fsync.c | 29 +++++++++++++++++++++++++++++
 dlls/ntdll/unix/fsync.h |  1 +
 dlls/ntdll/unix/sync.c  |  3 +++
 3 files changed, 33 insertions(+)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index af0d688b85c..feb5fc17100 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -510,6 +510,35 @@ NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev )
     return STATUS_SUCCESS;
 }
 
+NTSTATUS fsync_pulse_event( HANDLE handle, LONG *prev )
+{
+    struct event *event;
+    struct fsync *obj;
+    LONG current;
+    NTSTATUS ret;
+
+    TRACE("%p.\n", handle);
+
+    if ((ret = get_object( handle, &obj ))) return ret;
+    event = obj->shm;
+
+    /* This isn't really correct; an application could miss the write.
+     * Unfortunately we can't really do much better. Fortunately this is rarely
+     * used (and publicly deprecated). */
+    if (!(current = __atomic_exchange_n( &event->signaled, 1, __ATOMIC_SEQ_CST )))
+        futex_wake( &event->signaled, INT_MAX );
+
+    /* Try to give other threads a chance to wake up. Hopefully erring on this
+     * side is the better thing to do... */
+    NtYieldExecution();
+
+    __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
+
+    if (prev) *prev = current;
+
+    return STATUS_SUCCESS;
+}
+
 NTSTATUS fsync_query_event( HANDLE handle, void *info, ULONG *ret_len )
 {
     struct event *event;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index fe354b39dad..763e7891ab8 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -34,6 +34,7 @@ extern NTSTATUS fsync_open_event( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr );
 extern NTSTATUS fsync_set_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_reset_event( HANDLE handle, LONG *prev );
+extern NTSTATUS fsync_pulse_event( HANDLE handle, LONG *prev );
 extern NTSTATUS fsync_query_event( HANDLE handle, void *info, ULONG *ret_len );
 extern NTSTATUS fsync_create_mutex( HANDLE *handle, ACCESS_MASK access,
     const OBJECT_ATTRIBUTES *attr, BOOLEAN initial );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index 99edee33b63..c1785944f40 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -580,6 +580,9 @@ NTSTATUS WINAPI NtPulseEvent( HANDLE handle, LONG *prev_state )
 {
     unsigned int ret;
 
+    if (do_fsync())
+        return fsync_pulse_event( handle, prev_state );
+
     if (do_esync())
         return esync_pulse_event( handle );
 
-- 
2.46.0


From a1a2be68f718244db4788da0dd6759938583d8f8 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 7 Aug 2019 17:07:15 -0500
Subject: [PATCH 46/55] ntdll: Store the fsync APC futex in the thread data
 directly.

Essentially so we can take get_shm() out of any critical paths.
---
 dlls/ntdll/unix/fsync.c        | 26 +++++++++++++++-----------
 dlls/ntdll/unix/unix_private.h |  2 +-
 dlls/ntdll/unix/virtual.c      |  2 +-
 3 files changed, 17 insertions(+), 13 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index feb5fc17100..bf3581aa0cd 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -637,15 +637,15 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN aler
 
     if (alertable)
     {
-        struct event *apc_event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
+        int *apc_futex = ntdll_get_thread_data()->fsync_apc_futex;
         struct futex_wait_block futexes[2];
 
-        if (__atomic_load_n( &apc_event->signaled, __ATOMIC_SEQ_CST ))
+        if (__atomic_load_n( apc_futex, __ATOMIC_SEQ_CST ))
             return STATUS_USER_APC;
 
         futexes[0].addr = addr;
         futexes[0].val = val;
-        futexes[1].addr = &apc_event->signaled;
+        futexes[1].addr = apc_futex;
         futexes[1].val = 0;
 #if __SIZEOF_POINTER__ == 4
         futexes[0].pad = futexes[1].pad = 0;
@@ -663,7 +663,7 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN aler
         else
             ret = futex_wait_multiple( futexes, 2, NULL );
 
-        if (__atomic_load_n( &apc_event->signaled, __ATOMIC_SEQ_CST ))
+        if (__atomic_load_n( apc_futex, __ATOMIC_SEQ_CST ))
             return STATUS_USER_APC;
     }
     else
@@ -705,14 +705,21 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     int i, ret;
 
     /* Grab the APC futex if we don't already have it. */
-    if (alertable && !ntdll_get_thread_data()->fsync_apc_idx)
+    if (alertable && !ntdll_get_thread_data()->fsync_apc_futex)
     {
+        unsigned int idx = 0;
         SERVER_START_REQ( get_fsync_apc_idx )
         {
             if (!(ret = wine_server_call( req )))
-                ntdll_get_thread_data()->fsync_apc_idx = reply->shm_idx;
+                idx = reply->shm_idx;
         }
         SERVER_END_REQ;
+
+        if (idx)
+        {
+            struct event *apc_event = get_shm( idx );
+            ntdll_get_thread_data()->fsync_apc_futex = &apc_event->signaled;
+        }
     }
 
     NtQuerySystemTime( &now );
@@ -776,9 +783,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
             {
                 /* We must check this first! The server may set an event that
                  * we're waiting on, but we need to return STATUS_USER_APC. */
-                struct event *event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
-                TRACE("...%d\n", __atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ));
-                if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                if (__atomic_load_n( ntdll_get_thread_data()->fsync_apc_futex, __ATOMIC_SEQ_CST ))
                     goto userapc;
             }
 
@@ -890,9 +895,8 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 
             if (alertable)
             {
-                struct event *event = get_shm( ntdll_get_thread_data()->fsync_apc_idx );
                 /* We already checked if it was signaled; don't bother doing it again. */
-                futexes[i].addr = &event->signaled;
+                futexes[i].addr = ntdll_get_thread_data()->fsync_apc_futex;
                 futexes[i].val = 0;
 #if __SIZEOF_POINTER__ == 4
                 futexes[i].pad = 0;
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index c487ef487f0..cb6471509db 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -104,7 +104,7 @@ struct ntdll_thread_data
     void              *cpu_data[16];  /* reserved for CPU-specific data */
     void              *kernel_stack;  /* stack for thread startup and kernel syscalls */
     int                esync_apc_fd;  /* fd to wait on for user APCs */
-    unsigned int       fsync_apc_idx;
+    int               *fsync_apc_futex;
     int                request_fd;    /* fd for sending server requests */
     int                reply_fd;      /* fd for receiving server replies */
     int                wait_fd[2];    /* fd for sleeping server requests */
diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 3bcdd6c11c1..92bd36e2b4c 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -3683,7 +3683,7 @@ static TEB *init_teb( void *ptr, BOOL is_wow )
     teb->StaticUnicodeString.MaximumLength = sizeof(teb->StaticUnicodeBuffer);
     thread_data = (struct ntdll_thread_data *)&teb->GdiTebBatch;
     thread_data->esync_apc_fd = -1;
-    thread_data->fsync_apc_idx = 0;
+    thread_data->fsync_apc_futex = NULL;
     thread_data->request_fd = -1;
     thread_data->reply_fd   = -1;
     thread_data->wait_fd[0] = -1;
-- 
2.46.0


From e856c051296e42d2466ae1986c3a8e3e2cab44dc Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 7 Aug 2019 17:14:59 -0500
Subject: [PATCH 47/55] ntdll/fsync: Lock accessing the shm_addrs array.

---
 dlls/ntdll/unix/fsync.c | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index bf3581aa0cd..b2de9354939 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -134,10 +134,15 @@ static void **shm_addrs;
 static int shm_addrs_size;  /* length of the allocated shm_addrs array */
 static long pagesize;
 
+static pthread_mutex_t shm_addrs_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 static void *get_shm( unsigned int idx )
 {
     int entry  = (idx * 8) / pagesize;
     int offset = (idx * 8) % pagesize;
+    void *ret;
+
+    pthread_mutex_lock( &shm_addrs_mutex );
 
     if (entry >= shm_addrs_size)
     {
@@ -161,7 +166,11 @@ static void *get_shm( unsigned int idx )
             munmap( addr, pagesize ); /* someone beat us to it */
     }
 
-    return (void *)((unsigned long)shm_addrs[entry] + offset);
+    ret = (void *)((unsigned long)shm_addrs[entry] + offset);
+
+    pthread_mutex_unlock( &shm_addrs_mutex );
+
+    return ret;
 }
 
 /* We'd like lookup to be fast. To that end, we use a static list indexed by handle.
-- 
2.46.0


From 886aaa81de56c696bd8c7e44bd485298779b4ad3 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Thu, 8 Aug 2019 17:12:46 -0500
Subject: [PATCH 48/55] ntdll/fsync: Fix a race condition when waiting on a
 mutex.

---
 dlls/ntdll/unix/fsync.c | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index b2de9354939..d3d4a3943e7 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -834,6 +834,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                     case FSYNC_MUTEX:
                     {
                         struct mutex *mutex = obj->shm;
+                        int tid;
 
                         if (mutex->tid == GetCurrentThreadId())
                         {
@@ -842,7 +843,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             return i;
                         }
 
-                        if (!__sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() ))
+                        if (!(tid = __sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() )))
                         {
                             TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                             mutex->count = 1;
@@ -850,7 +851,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         }
 
                         futexes[i].addr = &mutex->tid;
-                        futexes[i].val  = mutex->tid;
+                        futexes[i].val  = tid;
                         break;
                     }
                     case FSYNC_AUTO_EVENT:
-- 
2.46.0


From 65287e4ecb31816e7815b13b63f3e8b0207f9d8d Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Mon, 19 Aug 2019 18:25:42 -0500
Subject: [PATCH 49/55] ntdll/fsync: Introduce a configurable spin count.

---
 dlls/ntdll/unix/fsync.c | 68 +++++++++++++++++++++++++++++------------
 1 file changed, 49 insertions(+), 19 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index d3d4a3943e7..2e633c51792 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -64,6 +64,15 @@ struct futex_wait_block
 };
 #include "poppack.h"
 
+static inline void small_pause(void)
+{
+#if defined(__i386__) || defined(__x86_64__)
+    __asm__ __volatile__( "rep;nop" : : : "memory" );
+#else
+    __asm__ __volatile__( "" : : : "memory" );
+#endif
+}
+
 static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
         int count, const struct timespec *timeout )
 {
@@ -80,6 +89,8 @@ static inline int futex_wait( int *addr, int val, struct timespec *timeout )
     return syscall( __NR_futex, addr, 0, val, timeout, 0, 0 );
 }
 
+static unsigned int spincount;
+
 int do_fsync(void)
 {
 #ifdef __linux__
@@ -90,6 +101,8 @@ int do_fsync(void)
         static const struct timespec zero;
         futex_wait_multiple( NULL, 0, &zero );
         do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
+        if (getenv("WINEFSYNC_SPINCOUNT"))
+            spincount = atoi(getenv("WINEFSYNC_SPINCOUNT"));
     }
 
     return do_fsync_cached;
@@ -707,6 +720,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     int has_fsync = 0, has_server = 0;
     BOOL msgwait = FALSE;
     int dummy_futex = 0;
+    unsigned int spin;
     LONGLONG timeleft;
     LARGE_INTEGER now;
     DWORD waitcount;
@@ -816,19 +830,23 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                         struct semaphore *semaphore = obj->shm;
                         int current;
 
-                        do
-                        {
-                            if (!(current = semaphore->count)) break;
-                        } while (__sync_val_compare_and_swap( &semaphore->count, current, current - 1 ) != current);
-
-                        if (current)
+                        /* It would be a little clearer (and less error-prone)
+                         * to use a dedicated interlocked_dec_if_nonzero()
+                         * helper, but nesting loops like that is probably not
+                         * great for performance... */
+                        for (spin = 0; spin <= spincount || current; ++spin)
                         {
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            return i;
+                            if ((current = __atomic_load_n( &semaphore->count, __ATOMIC_SEQ_CST ))
+                                    && __sync_val_compare_and_swap( &semaphore->count, current, current - 1 ) == current)
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                return i;
+                            }
+                            small_pause();
                         }
 
                         futexes[i].addr = &semaphore->count;
-                        futexes[i].val = current;
+                        futexes[i].val = 0;
                         break;
                     }
                     case FSYNC_MUTEX:
@@ -843,11 +861,15 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             return i;
                         }
 
-                        if (!(tid = __sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() )))
+                        for (spin = 0; spin <= spincount; ++spin)
                         {
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            mutex->count = 1;
-                            return i;
+                            if (!(tid = __sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() )))
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                mutex->count = 1;
+                                return i;
+                            }
+                            small_pause();
                         }
 
                         futexes[i].addr = &mutex->tid;
@@ -859,10 +881,14 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                     {
                         struct event *event = obj->shm;
 
-                        if (__sync_val_compare_and_swap( &event->signaled, 1, 0 ))
+                        for (spin = 0; spin <= spincount; ++spin)
                         {
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            return i;
+                            if (__sync_val_compare_and_swap( &event->signaled, 1, 0 ))
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                return i;
+                            }
+                            small_pause();
                         }
 
                         futexes[i].addr = &event->signaled;
@@ -875,10 +901,14 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                     {
                         struct event *event = obj->shm;
 
-                        if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                        for (spin = 0; spin <= spincount; ++spin)
                         {
-                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
-                            return i;
+                            if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                return i;
+                            }
+                            small_pause();
                         }
 
                         futexes[i].addr = &event->signaled;
-- 
2.46.0


From 7d960c435d17da8c8587a974dc215d98fb34ac3e Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Mon, 17 Feb 2020 11:57:40 -0600
Subject: [PATCH 50/55] ntdll, server: Abandon fsync mutexes on thread exit.

---
 dlls/ntdll/unix/fsync.c | 34 +++++++++++++++++++++++++++-------
 server/fsync.c          | 33 +++++++++++++++++++++++++++++++++
 server/fsync.h          |  1 +
 server/thread.c         |  2 ++
 4 files changed, 63 insertions(+), 7 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2e633c51792..2911773001b 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -636,7 +636,7 @@ NTSTATUS fsync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
 
     out->CurrentCount = 1 - mutex->count;
     out->OwnedByCaller = (mutex->tid == GetCurrentThreadId());
-    out->AbandonedState = FALSE;
+    out->AbandonedState = (mutex->tid == ~0);
     if (ret_len) *ret_len = sizeof(*out);
 
     return STATUS_SUCCESS;
@@ -869,6 +869,12 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                                 mutex->count = 1;
                                 return i;
                             }
+                            else if (tid == ~0 && (tid = __sync_val_compare_and_swap( &mutex->tid, ~0, GetCurrentThreadId() )) == ~0)
+                            {
+                                TRACE("Woken up by abandoned mutex %p [%d].\n", handles[i], i);
+                                mutex->count = 1;
+                                return STATUS_ABANDONED_WAIT_0 + i;
+                            }
                             small_pause();
                         }
 
@@ -1006,7 +1012,10 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
 
         while (1)
         {
+            BOOL abandoned;
 tryagain:
+            abandoned = FALSE;
+
             /* First step: try to wait on each object in sequence. */
 
             for (i = 0; i < count; i++)
@@ -1058,11 +1067,9 @@ tryagain:
                 if (obj && obj->type == FSYNC_MUTEX)
                 {
                     struct mutex *mutex = obj->shm;
+                    int tid = __atomic_load_n( &mutex->tid, __ATOMIC_SEQ_CST );
 
-                    if (mutex->tid == GetCurrentThreadId())
-                        continue;   /* ok */
-
-                    if (__atomic_load_n( &mutex->tid, __ATOMIC_SEQ_CST ))
+                    if (tid && tid != ~0 && tid != GetCurrentThreadId())
                         goto tryagain;
                 }
                 else if (obj)
@@ -1083,10 +1090,15 @@ tryagain:
                 case FSYNC_MUTEX:
                 {
                     struct mutex *mutex = obj->shm;
-                    if (mutex->tid == GetCurrentThreadId())
+                    int tid = __atomic_load_n( &mutex->tid, __ATOMIC_SEQ_CST );
+                    if (tid == GetCurrentThreadId())
                         break;
-                    if (__sync_val_compare_and_swap( &mutex->tid, 0, GetCurrentThreadId() ))
+                    if (tid && tid != ~0)
+                        goto tooslow;
+                    if (__sync_val_compare_and_swap( &mutex->tid, tid, GetCurrentThreadId() ) != tid)
                         goto tooslow;
+                    if (tid == ~0)
+                        abandoned = TRUE;
                     break;
                 }
                 case FSYNC_SEMAPHORE:
@@ -1122,6 +1134,11 @@ tryagain:
                 }
             }
 
+            if (abandoned)
+            {
+                TRACE("Wait successful, but some object(s) were abandoned.\n");
+                return STATUS_ABANDONED;
+            }
             TRACE("Wait successful.\n");
             return STATUS_SUCCESS;
 
@@ -1134,6 +1151,9 @@ tooslow:
                 case FSYNC_MUTEX:
                 {
                     struct mutex *mutex = obj->shm;
+                    /* HACK: This won't do the right thing with abandoned
+                     * mutexes, but fixing it is probably more trouble than
+                     * it's worth. */
                     __atomic_store_n( &mutex->tid, 0, __ATOMIC_SEQ_CST );
                     break;
                 }
diff --git a/server/fsync.c b/server/fsync.c
index ca57d7f9cb8..3ad59f4735f 100644
--- a/server/fsync.c
+++ b/server/fsync.c
@@ -129,11 +129,14 @@ void fsync_init(void)
     atexit( shm_cleanup );
 }
 
+static struct list mutex_list = LIST_INIT(mutex_list);
+
 struct fsync
 {
     struct object  obj;
     unsigned int   shm_idx;
     enum fsync_type type;
+    struct list     mutex_entry;
 };
 
 static void fsync_dump( struct object *obj, int verbose );
@@ -193,6 +196,9 @@ static unsigned int fsync_map_access( struct object *obj, unsigned int access )
 
 static void fsync_destroy( struct object *obj )
 {
+    struct fsync *fsync = (struct fsync *)obj;
+    if (fsync->type == FSYNC_MUTEX)
+        list_remove( &fsync->mutex_entry );
 }
 
 static void *get_shm( unsigned int idx )
@@ -297,6 +303,8 @@ struct fsync *create_fsync( struct object *root, const struct unicode_str *name,
 
             fsync->shm_idx = fsync_alloc_shm( low, high );
             fsync->type = type;
+            if (type == FSYNC_MUTEX)
+                list_add_tail( &mutex_list, &fsync->mutex_entry );
         }
         else
         {
@@ -397,6 +405,31 @@ void fsync_reset_event( struct fsync *fsync )
     __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
 }
 
+struct mutex
+{
+    int tid;
+    int count;  /* recursion count */
+};
+
+void fsync_abandon_mutexes( struct thread *thread )
+{
+    struct fsync *fsync;
+
+    LIST_FOR_EACH_ENTRY( fsync, &mutex_list, struct fsync, mutex_entry )
+    {
+        struct mutex *mutex = get_shm( fsync->shm_idx );
+
+        if (mutex->tid == thread->id)
+        {
+            if (debug_level)
+                fprintf( stderr, "fsync_abandon_mutexes() idx=%d\n", fsync->shm_idx );
+            mutex->tid = ~0;
+            mutex->count = 0;
+            futex_wake( &mutex->tid, INT_MAX );
+        }
+    }
+}
+
 DECL_HANDLER(create_fsync)
 {
     struct fsync *fsync;
diff --git a/server/fsync.h b/server/fsync.h
index f6f1a48b31e..a91939b7f0a 100644
--- a/server/fsync.h
+++ b/server/fsync.h
@@ -31,3 +31,4 @@ struct fsync;
 extern const struct object_ops fsync_ops;
 extern void fsync_set_event( struct fsync *fsync );
 extern void fsync_reset_event( struct fsync *fsync );
+extern void fsync_abandon_mutexes( struct thread *thread );
diff --git a/server/thread.c b/server/thread.c
index 321d6e74c7d..c8a69f05e9f 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -1375,6 +1375,8 @@ void kill_thread( struct thread *thread, int violent_death )
     }
     kill_console_processes( thread, 0 );
     abandon_mutexes( thread );
+    if (do_fsync())
+        fsync_abandon_mutexes( thread );
     if (do_esync())
         esync_abandon_mutexes( thread );
     if (violent_death)
-- 
2.46.0


From 98827f3a3cb7a748f805be0ed7ebd3cb53437028 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Wed, 18 Mar 2020 20:03:42 -0500
Subject: [PATCH 51/55] ntdll: Default the spin count to 100.

---
 dlls/ntdll/unix/fsync.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 2911773001b..bde99d0e8e4 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -89,7 +89,7 @@ static inline int futex_wait( int *addr, int val, struct timespec *timeout )
     return syscall( __NR_futex, addr, 0, val, timeout, 0, 0 );
 }
 
-static unsigned int spincount;
+static unsigned int spincount = 100;
 
 int do_fsync(void)
 {
-- 
2.46.0


From e64d65ed9d9d2a707d7cc1934cc97f4d55c3aa88 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <zfigura@codeweavers.com>
Date: Fri, 13 Mar 2020 15:52:15 -0500
Subject: [PATCH 52/55] ntdll: Implement an esync/fsync path for alertable
 NtDelayExecution().

---
 dlls/ntdll/unix/esync.c |  4 ++--
 dlls/ntdll/unix/fsync.c |  6 +++---
 dlls/ntdll/unix/sync.c  | 19 ++++++++++++++++++-
 3 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 57806b54673..491bfa4124a 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -865,7 +865,7 @@ static NTSTATUS __esync_wait_objects( unsigned int count, const HANDLE *handles,
             return ret;
     }
 
-    if (objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
+    if (count && objs[count - 1] && objs[count - 1]->type == ESYNC_QUEUE)
         msgwait = TRUE;
 
     if (has_esync && has_server)
@@ -894,7 +894,7 @@ static NTSTATUS __esync_wait_objects( unsigned int count, const HANDLE *handles,
         }
     }
 
-    if (wait_any || count == 1)
+    if (wait_any || count <= 1)
     {
         /* Try to check objects now, so we can obviate poll() at least. */
         for (i = 0; i < count; i++)
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index bde99d0e8e4..78c007cf814 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -767,7 +767,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
             return ret;
     }
 
-    if (objs[count - 1] && objs[count - 1]->type == FSYNC_QUEUE)
+    if (count && objs[count - 1] && objs[count - 1]->type == FSYNC_QUEUE)
         msgwait = TRUE;
 
     if (has_fsync && has_server)
@@ -796,7 +796,7 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
         }
     }
 
-    if (wait_any || count == 1)
+    if (wait_any || count <= 1)
     {
         while (1)
         {
@@ -1222,7 +1222,7 @@ NTSTATUS fsync_wait_objects( DWORD count, const HANDLE *handles, BOOLEAN wait_an
     struct fsync *obj;
     NTSTATUS ret;
 
-    if (!get_object( handles[count - 1], &obj ) && obj->type == FSYNC_QUEUE)
+    if (count && !get_object( handles[count - 1], &obj ) && obj->type == FSYNC_QUEUE)
     {
         msgwait = TRUE;
         server_set_msgwait( 1 );
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index c1785944f40..3e2d9b55f32 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1758,7 +1758,24 @@ NTSTATUS WINAPI NtYieldExecution(void)
 NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
     /* if alertable, we need to query the server */
-    if (alertable) return server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
+    if (alertable)
+    {
+        if (do_fsync())
+        {
+            NTSTATUS ret = fsync_wait_objects( 0, NULL, TRUE, TRUE, timeout );
+            if (ret != STATUS_NOT_IMPLEMENTED)
+                return ret;
+        }
+
+        if (do_esync())
+        {
+            NTSTATUS ret = esync_wait_objects( 0, NULL, TRUE, TRUE, timeout );
+            if (ret != STATUS_NOT_IMPLEMENTED)
+                return ret;
+        }
+
+        return server_wait( NULL, 0, SELECT_INTERRUPTIBLE | SELECT_ALERTABLE, timeout );
+    }
 
     if (!timeout || timeout->QuadPart == TIMEOUT_INFINITE)  /* sleep forever */
     {
-- 
2.46.0


From acaf0b0ed3a36241468fb6ca5d269185edf32300 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Almeida?= <andrealmeid@collabora.com>
Date: Fri, 27 Nov 2020 14:05:14 -0300
Subject: [PATCH 53/55] ntdll: Call waitv just when nr_futexes > 1
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

futex_waitv() needs to do an extra copy from userspace compared to
futex(), so use the latter when we are waiting in a single futex.

Signed-off-by: Andr Almeida <andrealmeid@collabora.com>
Link: https://github.com/ValveSoftware/wine/pull/128
---
 dlls/ntdll/unix/fsync.c | 12 ++++++++++--
 1 file changed, 10 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 78c007cf814..b38d42cce65 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -968,10 +968,18 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
                 tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
 
-                ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
+                if (waitcount == 1)
+                    ret = futex_wait( futexes[0].addr, futexes[0].val, &tmo_p );
+                else
+                    ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
             }
             else
-                ret = futex_wait_multiple( futexes, waitcount, NULL );
+            {
+                if (waitcount == 1)
+                    ret = futex_wait( futexes[0].addr, futexes[0].val, NULL );
+                else
+                    ret = futex_wait_multiple( futexes, waitcount, NULL );
+            }
 
             /* FUTEX_WAIT_MULTIPLE can succeed or return -EINTR, -EAGAIN,
              * -EFAULT/-EACCES, -ETIMEDOUT. In the first three cases we need to
-- 
2.46.0


From ca67de3c943fbf512509ec0a18d68cf1ba875ef1 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 25 Jun 2021 23:17:43 +0300
Subject: [PATCH 54/55] esync, fsync: Use usleep(0) instead of
 NtYieldExecution() in esync_pulse_event().

For Mafia III: Definitive Edition when FPS limit is set.

CW-Bug-Id: #19024
---
 dlls/ntdll/unix/esync.c | 2 +-
 dlls/ntdll/unix/fsync.c | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/dlls/ntdll/unix/esync.c b/dlls/ntdll/unix/esync.c
index 491bfa4124a..cbfbac7d9e6 100644
--- a/dlls/ntdll/unix/esync.c
+++ b/dlls/ntdll/unix/esync.c
@@ -623,7 +623,7 @@ NTSTATUS esync_pulse_event( HANDLE handle )
 
     /* Try to give other threads a chance to wake up. Hopefully erring on this
      * side is the better thing to do... */
-    NtYieldExecution();
+    usleep(0);
 
     read( obj->fd, &value, sizeof(value) );
 
diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index b38d42cce65..c56d56f3d10 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -552,7 +552,7 @@ NTSTATUS fsync_pulse_event( HANDLE handle, LONG *prev )
 
     /* Try to give other threads a chance to wake up. Hopefully erring on this
      * side is the better thing to do... */
-    NtYieldExecution();
+    usleep(0);
 
     __atomic_store_n( &event->signaled, 0, __ATOMIC_SEQ_CST );
 
-- 
2.46.0


From 920d14578306f40d91afe5a97a84e9deec49a374 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Andr=C3=A9=20Almeida?= <andrealmeid@collabora.com>
Date: Wed, 20 Oct 2021 10:35:58 -0300
Subject: [PATCH 55/55] ntdll/fsync: Encapsulate timeout conversion
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Simplify the wait path by dealing with the timeout conversion
inside of futex_wait.

Signed-off-by: Andr Almeida <andrealmeid@collabora.com>
Link: https://github.com/ValveSoftware/wine/pull/128

----

[PATCH] Fix error compilation by Alexis Peypelut

Signed-off-by: IroAlexis <iroalexis@outlook.fr>
---
 dlls/ntdll/unix/fsync.c | 96 ++++++++++++++++++-----------------------
 1 file changed, 43 insertions(+), 53 deletions(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index c56d56f3d10..c92da2442b4 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -73,10 +73,32 @@ static inline void small_pause(void)
 #endif
 }
 
+static LONGLONG update_timeout( ULONGLONG end )
+{
+    LARGE_INTEGER now;
+    LONGLONG timeleft;
+
+    NtQuerySystemTime( &now );
+    timeleft = end - now.QuadPart;
+    if (timeleft < 0) timeleft = 0;
+    return timeleft;
+}
+
 static inline int futex_wait_multiple( const struct futex_wait_block *futexes,
-        int count, const struct timespec *timeout )
+        int count, const ULONGLONG *end )
 {
-    return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
+   if (end)
+   {
+        LONGLONG timeleft = update_timeout( *end );
+        struct timespec timeout;
+        timeout.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+        timeout.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+        return syscall( __NR_futex, futexes, 31, count, timeout, 0, 0 );
+   }
+   else
+   {
+        return syscall( __NR_futex, futexes, 31, count, NULL, 0, 0 );
+   }
 }
 
 static inline int futex_wake( int *addr, int val )
@@ -84,9 +106,20 @@ static inline int futex_wake( int *addr, int val )
     return syscall( __NR_futex, addr, 1, val, NULL, 0, 0 );
 }
 
-static inline int futex_wait( int *addr, int val, struct timespec *timeout )
+static inline int futex_wait( int *addr, int val, const ULONGLONG *end )
 {
-    return syscall( __NR_futex, addr, 0, val, timeout, 0, 0 );
+    if (end)
+    {
+        LONGLONG timeleft = update_timeout( *end );
+        struct timespec timeout;
+        timeout.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
+        timeout.tv_nsec = (timeleft % TICKSPERSEC) * 100;
+        return syscall( __NR_futex, addr, 0, val, &timeout, 0, 0 );
+    }
+    else
+    {
+        return syscall( __NR_futex, addr, 0, val, NULL, 0, 0 );
+    }
 }
 
 static unsigned int spincount = 100;
@@ -98,7 +131,7 @@ int do_fsync(void)
 
     if (do_fsync_cached == -1)
     {
-        static const struct timespec zero;
+        ULONGLONG zero;
         futex_wait_multiple( NULL, 0, &zero );
         do_fsync_cached = getenv("WINEFSYNC") && atoi(getenv("WINEFSYNC")) && errno != ENOSYS;
         if (getenv("WINEFSYNC_SPINCOUNT"))
@@ -642,17 +675,6 @@ NTSTATUS fsync_query_mutex( HANDLE handle, void *info, ULONG *ret_len )
     return STATUS_SUCCESS;
 }
 
-static LONGLONG update_timeout( ULONGLONG end )
-{
-    LARGE_INTEGER now;
-    LONGLONG timeleft;
-
-    NtQuerySystemTime( &now );
-    timeleft = end - now.QuadPart;
-    if (timeleft < 0) timeleft = 0;
-    return timeleft;
-}
-
 static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN alertable )
 {
     int ret;
@@ -674,32 +696,14 @@ static NTSTATUS do_single_wait( int *addr, int val, ULONGLONG *end, BOOLEAN aler
 #endif
         futexes[0].bitset = futexes[1].bitset = ~0;
 
-        if (end)
-        {
-            LONGLONG timeleft = update_timeout( *end );
-            struct timespec tmo_p;
-            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-            ret = futex_wait_multiple( futexes, 2, &tmo_p );
-        }
-        else
-            ret = futex_wait_multiple( futexes, 2, NULL );
+        ret = futex_wait_multiple( futexes, 2, end );
 
         if (__atomic_load_n( apc_futex, __ATOMIC_SEQ_CST ))
             return STATUS_USER_APC;
     }
     else
     {
-        if (end)
-        {
-            LONGLONG timeleft = update_timeout( *end );
-            struct timespec tmo_p;
-            tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-            tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
-            ret = futex_wait( addr, val, &tmo_p );
-        }
-        else
-            ret = futex_wait( addr, val, NULL );
+        ret = futex_wait( addr, val, end );
     }
 
     if (!ret)
@@ -961,25 +965,11 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                 TRACE("Wait timed out.\n");
                 return STATUS_TIMEOUT;
             }
-            else if (timeout)
-            {
-                LONGLONG timeleft = update_timeout( end );
-                struct timespec tmo_p;
-                tmo_p.tv_sec = timeleft / (ULONGLONG)TICKSPERSEC;
-                tmo_p.tv_nsec = (timeleft % TICKSPERSEC) * 100;
 
-                if (waitcount == 1)
-                    ret = futex_wait( futexes[0].addr, futexes[0].val, &tmo_p );
-                else
-                    ret = futex_wait_multiple( futexes, waitcount, &tmo_p );
-            }
+            if (waitcount == 1)
+                ret = futex_wait( futexes[0].addr, futexes[0].val, timeout ? &end : NULL );
             else
-            {
-                if (waitcount == 1)
-                    ret = futex_wait( futexes[0].addr, futexes[0].val, NULL );
-                else
-                    ret = futex_wait_multiple( futexes, waitcount, NULL );
-            }
+                ret = futex_wait_multiple( futexes, waitcount, timeout ? &end : NULL );
 
             /* FUTEX_WAIT_MULTIPLE can succeed or return -EINTR, -EAGAIN,
              * -EFAULT/-EACCES, -ETIMEDOUT. In the first three cases we need to
-- 
2.46.0

